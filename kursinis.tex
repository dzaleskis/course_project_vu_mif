\documentclass{VUMIFInfKursinis}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{color}
\usepackage{graphicx}
% \usepackage{hyperref}  % Nuorodų aktyvavimas
\usepackage{url}

\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

% Titulinio aprašas
\university{Vilniaus universitetas}
\faculty{Matematikos ir informatikos fakultetas}
\institute{Informatikos institutas}  % Užkomentavus šią eilutę - institutas neįtraukiamas į titulinį
\department{Informatikos katedra}
\papertype{Kursinis darbas}
\title{Rikiavimo tobulinimas genetiniais algoritmais}
\titleineng{Improving sorting with genetic algorithms}
\status{3 kurso 2 grupės studentas}
\author{Deividas Zaleskis}
\supervisor{Irmantas Radavičius}
\date{Vilnius \\ \the\year}

% Nustatymai
\bibliography{bibliografija} 

\begin{document}
\maketitle

\tableofcontents

\sectionnonum{Įvadas}

Viena pagrindinių informatikos sąvokų yra algoritmas.
Formaliai algoritmą galima apibūdinti kaip
baigtinę seką instrukcijų, nurodančių kaip rasti nagrinėjamo uždavinio sprendinį.
Algoritmo koncepcija egzistuoja nuo senovės laikų \cite{knuth1972ancient}, tačiau atsiradus kompiuteriams,
tapo įmanoma algoritmų vykdymą automatizuoti, paverčiant juos mašininiu kodu suprantamu kompiuteriams \cite{wilkes1951preparation}.
Taip informatikos mokslas nuo teorinių šaknų \cite{turing1937computable} įgavo ir taikomąją pusę.
Beveik visus algoritmus galima suskirstyti į dvi klases: kombinatorinius algoritmus ir skaitinius algoritmus.
Skaitiniai algoritmai sprendžia tolydžius uždavinius: optimizuoti realaus argumento funkciją, išspręsti tiesinių lygčių sistemą su realiais koeficientais, etc.
Kombinatoriniai algoritmai sprendžia diskrečius uždavinius ir operuoja diskrečiais objektais: skaičiais, sąrašais, grafais, etc.
Vienas žinomiausių diskretaus uždavinio pavyzdžių yra duomenų rikiavimas.

Duomenų rikiavimas yra vienas pamatinių informatikos uždavinių.
Matematiškai jis formuluojamas taip:
duotai baigtinei palyginamų elementų sekai $S = (s_1, s_2, ..., s_n)$ pateikti tokį
kėlinį, kad pradinės sekos elementai būtų išdėstyti didėjančia (mažėjančia) tvarka \cite{Radavičius_Baranauskas_2013}.
Rikiavimo uždavinys yra aktualus nuo pat kompiuterių atsiradimo ir buvo laikomas vienu 
pagrindinių diskrečių uždavinių, kuriuos turėtų gebėti spręsti kompiuteris \cite{10.1145/356580.356581}.
Rikiavimo uždavinio sprendimas dažnai padeda pagrindą efektyviam kito uždavinio sprendimui,
pavyzdžiui, atliekant paiešką sąraše, galima taikyti dvejetainės paieškos algoritmą tik tada,
kai sąrašas yra išrikiuotas.
Kadangi rikiavimo uždavinys yra fundamentalus, jam spręsti egzistuoja labai skirtingų algoritmų.

Rikiavimo algoritmų yra įvairių:
paremtų palyginimu (elementų tvarką nustato naudojant palyginimo operatorius),
stabilių (nekeičia lygių elementų tvarkos),
nenaudojančių papildomos atminties (atminties sudėtingumas yra $O(1)$), etc.
Asimptotiškai optimalūs palyginimu paremti algoritmai blogiausiu atveju turi $O(n\,log\,n)$ laiko sudėtingumą,
o ne palyginimu paremti algoritmai gali veikti dar greičiau, tačiau nėra tokie universalūs, kadangi rikiuojama remiantis duomenų specifika.
Tiesa, rikiuojant remtis vien algoritmo asimptotika nepakanka:
rikiavimas įterpimu (angl. insertion sort) blogiausiu atveju turi $O(n^2)$ laiko sudėtingumą \cite{bender2006insertion},
tačiau mažesnius elementų kiekius rikiuoja daug greičiau, nei asimptotiškai optimalūs algoritmai,
pavyzdžiui, rikiavimas krūva (angl. heapsort) \cite{10.1145/512274.512284}.
Todėl pastaruoju metu plačiai naudojami hibridiniai rikiavimo algoritmai, kurie sujungia keletą rikiavimo
algoritmų į vieną ir panaudoja jų geriausias savybes.
Nepaisant įvairovės ir naujų algoritmų gausos, klasikiniai rikiavimo algoritmai išlieka aktualūs. % ir yra nuolat tobulinami

Šelo rikiavimo algoritmas (angl. Shellsort, toliau - Šelo algoritmas) \cite{10.1145/368370.368387} yra paremtas palyginimu, nenaudojantis papildomos atminties ir nestabilus.
Šelo algoritmą galima laikyti rikiavimo įterpimu modifikacija,
kuri lygina ne gretimus, o toliau vienas nuo kito esančius elementus, taip paspartindama jų perkėlimą į galutinę poziciją.
Pagrindinė algoritmo idėja - išskaidyti rikiuojamą seką S į posekius $S_1, S_2, ..., S_n$,
kur kiekvienas posekis $S_i = (s_i, s_{i+h}, s_{i+2h}, ...)$ yra sekos S elementai, kurių pozicija skiriasi $h$.
Išrikiavus visus sekos $S$ posekius $S_i$ su tarpu $h$, seka tampa $h$-išrikiuota.
Remiantis tuo, jog sekai S esant $h$-išrikiuota ir ją $k$-išrikiavus, ji lieka $h$-išrikiuota \cite{GALE1972103},
galima kiekvieną algoritmo iteraciją mažinti tarpą, taip vis didinant sekos $S$ išrikiuotumą. % rikiuotuma??
Pritaikant šias idėjas ir rikiavimui naudojant mažėjančią tarpų seką su paskutiniu nariu $1$,
kuris garantuoja rikiavimą įterpimu paskutinėje iteracijoje,
galima užtikrinti, jog algoritmo darbo pabaigoje seka S bus pilnai išrikiuota.
Įvertinant Šelo algoritmo idėjas, nesunku pastebėti tarpų sekų įtaką jo veikimui.

Šelo algoritmo efektyvumas tiesiogiai priklauso nuo pasirinktos tarpų sekos.
Weiss atlikto tyrimo \cite{weiss1991short} rezultatai rodo, jog su Sedgewick pasiūlyta seka
šis algoritmas veikia beveik dvigubai greičiau nei Šelo pradinis variantas, kai $n = 1000000$.
Yra įrodyta, kad Šelo algoritmo laiko sudėtingumo blogiausiu atveju apatinė riba yra
$\Omega(\frac{n\,log^2\,n}{log\,log\,n^2})$ \cite{267769}, taigi jis nėra asimptotiškai optimalus.
Tiesa, kol kas nėra rasta seka, su kuria Šelo algoritmas pasiektų šią apatinę ribą.
Kiek žinoma autoriui, asimptotiškai geriausia tarpų seka yra rasta Pratt, kuri yra formos
$2^p3^p$ ir turi $\Theta(n\,log^2\,n)$ laiko sudėtingumą \cite{pratt1972shellsort},
tačiau praktikoje ji veikia lėčiau už Ciura \cite{ciura2001best} ar Tokuda \cite{10.5555/645569.659879} pasiūlytas sekas.
Daugelio praktikoje efektyvių sekų asimptotinis sudėtingumas laiko atžvilgiu lieka atvira problema,
nes jos yra rastos eksperimentiškai.
Vienas iš metodų, kuriuos galima taikyti efektyvių tarpų sekų radimui, yra genetinis algoritmas.

Genetinis algoritmas (GA) yra metodas rasti euristikas, paremtas biologijos žiniomis apie natūralios atrankos procesą.
Kartu su genetiniu programavimu, evoliuciniais algoritmais ir kitais metodais, % citations needed
genetiniai algoritmai sudaro evoliucinių skaičiavimų šeimą.
Visi šios šeimos atstovai yra paremti pradinės populiacijos generavimu ir iteraciniu populiacijos atnaujinimu naudojant biologijos įkvėptas strategijas.
J.H. Holland, GA pradininkas, savo knygoje \cite{holland1992adaptation}
apibrėžė genetinio algoritmo sąvoką ir su ja glaudžiai susijusias
chromosomų (potencialių uždavinio sprendinių, išreikštų genų rinkiniu), bei
rekombinacijos (tėvinių chromosomų genų perdavimo palikuonims),
atrankos (tinkamiausių chromosomų atrinkimo) ir mutacijos (savaiminio chromosomos genų kitimo) operatorių koncepcijas.
Genetinių algoritmų veikimo strategija pagrįsta pradinės chromosomų populiacijos evoliucija, kiekvienos naujos chromosomų kartos
gavimui naudojant rekombinacijos, atrankos ir mutacijos operatorius.
Toliau bus aptariamos genetinių algoritmų taikymo galimybės.

Genetiniai algoritmai taikomi sprendžiant įvairius paieškos ir optimizavimo uždavinius, kuomet nesunku nustatyti, ar sprendinys tinkamas,
tačiau tinkamo sprendinio radimas reikalauja daug resursų ar net pilno perrinkimo.
Tokiu atveju apytikslio sprendinio radimas (euristika) gali būti daug patrauklesnis sprendimo būdas,
kadangi tikslaus sprendinio radimas dažnai yra NP-sunkus uždavinys.
Todėl GA yra pritaikomi sudarant grafikus ir tvarkaraščius,
sprendžiant globalaus optimizavimo uždavinius
ir net projektuojant NASA mikrosatelitų antenas \cite{hornby2006automated}.
Nesunku pastebėti, jog efektyvių Šelo algoritmo tarpų sekų radimas yra sunkus uždavinys atliekamų skaičiavimų prasme,
tikėtinai reikalaujantis pilno potencialių sprendinių perrinkimo,
tad šio uždavinio sprendimui taikyti GA yra prasminga.
Kiek žinoma autoriui, kol kas yra buvę du bandymai taikyti genetinius algoritmus efektyvių Šelo algoritmo tarpų sekų radimui \cite{simpson1999faster} \cite{roos2002genetic}.
Abiejuose darbuose teigiama, jog genetiniais algoritmais gautos tarpų sekos veikia greičiau už Sedgewick seką, kuri literatūroje laikoma viena efektyviausių.

\pagebreak

Darbo \textbf{tikslas}:
pritaikyti genetinius algoritmus Šelo algoritmo tarpų sekoms generuoti.

Darbo uždaviniai:
\begin{itemize}
  \item Nustatyti kriterijus tarpų sekų efektyvumui įvertinti.
  \item Paruošti aplinką eksperimentų vykdymui.
  \item Naudojant genetinius algoritmus sugeneruoti tarpų sekas.
  \item Atliekant eksperimentus įvertinti sugeneruotų ir pateiktų literatūroje tarpų sekų efektyvumą.
\end{itemize}

Šis darbas sudarytas iš 4 skyrių.
Pirmame skyriuje nustatomi kriterijai tarpų sekų efektyvumui įvertinti.
Antrame skyriuje paruošiama eksperimentų vykdymo aplinka.
Trečiame skyriuje generuojamos tarpų sekos, naudojant genetinius algoritmus.
Ketvirtame skyriuje atliekant eksperimentus įvertinamas sugeneruotų ir pateiktų literatūroje tarpų sekų efektyvumas.

\section{Tarpų sekų efektyvumo kriterijų nustatymas}

Šelo algoritmo tarpų sekų efektyvumo įvertinimas nėra trivialus.
Rikiavimo algoritmai dažniausiai yra vertinami pagal atliekamų priskyrimų skaičių.
Skaičiuojant algoritmo atliekamus priskyrimus, gana paprasta jais išreikšti inversijų skaičių. % o kodel inversijos svarbu?
Daugelyje algoritmų priskyrimų skaičius uždaviniui augant greitai artėja prie palyginimų skaičiaus,
tad tokiu metodu gautas įvertis būna pakankamai tikslus.
Šelo algoritmo atveju, vien priskyrimų skaičius nėra pakankamai tikslus kriterijus tarpų sekų efektyvumui įvertinti,
kadangi remiantis tik juo, gautas įvertis neatspindi praktinio efektyvumo.
Kaip parodo \cite{ciura2001best}, šiame algoritme dominuojanti operacija yra palyginimas.
Tad galima daryti išvadą, jog atliekamų palyginimų skaičius yra tinkamesnis kriterijus efektyvumui įvertinti.

Matuojant rikiavimo algoritmo efektyvumą tik naudojant sveikaskaitinius pradinius duomenis, gauti rezultatai gali būti netikslūs,
kadangi šių operacijų sparta priklauso nuo rikiuojamų duomenų tipo.
Rikiuojant simbolių eilutes, priskyrimas atliekamas naudojant rodykles, kas yra $O(1)$ operacija,
tačiau palyginimas yra $O(n)$ blogiausiu atveju.
Ir atvirkščiai, rikiuojant įrašus kurie saugomi steke, priskyrimas reikalauja perkopijuoti visą įrašą,
o palyginimas gali būti atliekamas naudojant tam tikrą raktą.
Todėl apsiriboti vien palyginimų ar priskyrimų skaičiumi nepakanka, kadangi tiksliausia praktinio algoritmo
veikimo laiko aproksimacija (tai, kam ir skaičiuojamos operacijos), bus gauta tik įvertinant abu šiuos rodiklius.

Algoritmo veikimo laikas, nors ir priklausomas nuo platformos, kurioje vykdomas tyrimas, detalių,
taip pat gali duoti tinkamų įžvalgų įvertinant praktinį efektyvumą.
Kadangi algoritmo atliekamos operacijos skaičiuojamos tam, jog gauti praktinio
veikimo laiko aproksimaciją, tai realus veikimo laikas
yra konkretus įvertis, leidžiantis praktiškai įvertinti duotos sekos efektyvumą.
Taigi, įvertinant tarpų sekų efektyvumą bus remiamasi visomis atliekamomis operacijomis bei realiais veikimo laikais.

\section{Eksperimentų vykdymo aplinkos paruošimas}

\subsection{Techninės detalės}
Tyrimui buvo naudotas kompiuteris su 2.70 GHz Intel(R) Core(TM) i7-10850H procesoriumi,
32 GB operatyviosios atminties ir Windows 10 operacine sistema.
Tyrimas buvo įgyvendintas C++ kalba su GNU g++ 8.1.0 kompiliatoriumi.
Genetinio algoritmo implementacijai buvo pasirinkta OpenGA biblioteka \cite{mohammadi2017openga}
dėl suteikiamos laisvės pasirinkti, kaip įgyvendinti genetinius operatorius bei modernių kalbos konstruktų ir lygiagretaus vykdymo palaikymo.

\subsection{Šelo rikiavimo algoritmo variantai}

Kaip ir daugelis algoritmų, Šelo rikiavimo algoritmas turi keletą variantų.
Kaip pabrėžia \cite{Radavičius_Baranauskas_2013}, vadovėlinė šio algoritmo implementacija nėra
naši, kadangi atlieka nereikalingus priskyrimus,
todėl buvo pasirinkta atlikti matavimus naudojant ir vadovėlinę, ir patobulintą šio algoritmo versiją.
Abiejų algoritmų pseudokodas pateikiamas žemiau.

\begin{algorithm}
  \caption{Vadovėlinis Šelo rikiavimo algoritmas}\label{css}
  \begin{algorithmic}[1]
  \ForEach {$gap$ \textbf{in} $H$}
    \For {$i\gets gap+1$ \textbf{to} $N$}
      \State $j\gets i$
      \State $temp\gets S[i]$
      \While {$j > gap$ \textbf{and} $S[j - gap] > S[j]$}
        \State $S[j]\gets S[j - gap]$
        \State $j\gets j-gap$
      \EndWhile
      \State $S[j]\gets temp$
    \EndFor
  \EndFor
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Patobulintas Šelo rikiavimo algoritmas}\label{iss}
  \begin{algorithmic}[1]
  \ForEach {$gap$ \textbf{in} $H$}
    \For {$i\gets gap+1$ \textbf{to} $N$}
      \If {$S[i-gap] > S[i]$}
        \State $j\gets i$
        \State $temp\gets S[i]$
        \Repeat
          \State $S[j]\gets S[j - gap]$
          \State $j\gets j-gap$
        \Until {$j \le gap$ or $S[j - gap] \le S[j]$}
        \State $S[j]\gets temp$
      \EndIf
    \EndFor
  \EndFor
  \end{algorithmic}
\end{algorithm}

\subsection{Pasiruošimas matavimų atlikimui}
Siekant išmatuoti abiejų algoritmų atliekamų operacijų skaičių, buvo parengtos modifikuotos jų
versijos, kurios kaip rezultatą grąžina atliktus palyginimus bei priskyrimus.
Tiesa, matuoti algoritmų veikimo laiką naudojant šias versijas nėra tinkama,
kadangi jos atlieka papildomus žingsnius ir gali iškreipti gautus rezultatus.
Atsižvelgiant į tai, veikimo laiko matavimui naudotos nemodifikuotos abiejų algoritmų implementacijos. 

\begin{algorithm}
  \caption{Vadovėlinis operacijas skaičiuojantis Šelo rikiavimo algoritmas}\label{css_reported}
  \begin{algorithmic}[1]
  \State $cmp\gets 0$
  \State $asn\gets 0$
  \ForEach {$gap$ \textbf{in} $H$}
    \For {$i\gets gap+1$ \textbf{to} $N$}
      \State $cmp\gets cmp+1$
      \State $j\gets i$
      \State $temp\gets S[i]$
      \State $asn\gets asn+2$
      \While {$j > gap$  \textbf{and} $S[j - gap] > S[j]$}
        \State $S[j]\gets S[j - gap]$
        \State $j\gets j-gap$
        \State $asn\gets asn+2$
        \State $cmp\gets cmp+2$
      \EndWhile
      \If {$j < gap$}
        \State $cmp\gets cmp+1$
      \Else
        \State $cmp\gets cmp+2$
      \EndIf
      \State $S[j]\gets temp$
      \State $asn\gets asn+1$
    \EndFor
  \EndFor
  \State \textbf{return} $(asn, cmp)$
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Patobulintas operacijas skaičiuojantis Šelo rikiavimo algoritmas}\label{iss_reported}
  \begin{algorithmic}[1]
  \ForEach {$gap$ \textbf{in} $H$}
    \For {$i\gets gap+1$ \textbf{to} $N$}
      \If {$S[i-gap] > S[i]$}
        \State $j\gets i$
        \State $temp\gets S[i]$
        \Repeat
          \State $S[j]\gets S[j - gap]$
          \State $j\gets j-gap$
        \Until {$j \le gap$ or $S[j - gap] \le S[j]$}
        \State $S[j]\gets temp$
      \EndIf
    \EndFor
  \EndFor
  \end{algorithmic}
\end{algorithm}

\section{Sekų generavimas}

\subsection{Genetinis algoritmas}

\subsection{Galinių sekų generavimas}
Pirmame sekų generavimo etape buvo generuojamos tarpų sekos, kurios efektyvios kai $N=1000$.
Remiantis \cite{simpson1999faster}, tokios sekos chromosoma buvo modeliuojama kaip
septynių sveikų skaičių masyvas.
Toliau šios sekos vadinamos galinėmis sekomis.
Galinių sekų generavimui buvo paruoštas vienkriterinis genetinis algoritmas.
Chromosomos buvo vertinamos jas naudojant 20-ties atsitiktinai
sugeneruotų sveikų skaičių masyvų rikiavimui vadovėline Šelo rikiavimo algoritmo versija ir skaičiuojant atliktas palyginimo operacijas.
Chromosomos tinkamumo funkcija buvo apibrėžta kaip atliktų palyginimų skaičiaus aritmetinis vidurkis.
Rekombinacijos operatorius buvo įgyvendintas tolygia strategija, kur abiejų tėvų genai turi vienodą tikimybę
būti perduoti vaikinei chromosomai.
Mutacijos operatorius buvo įgyvendintas su $\frac{1}{2}$ tikimybe keičiant kiekvieną chromosomos geną,
pridedant prie jo atsitiktinį skaičių iš intervalo $[-100, 100]$ su apribojimu, jog pakeistas genas turi priklausyti intervalui $[1, 1000]$.

Pirmiausia algoritmas buvo vykdomas su atsitiktinai sugeneruota 10000 individų populiacija, kiekvieną iteraciją pritaikant mutacijos ir rekombinacijos operatorius
atitinkamai $\frac{8}{10}$ ir $\frac{1}{10}$ populiacijos.
Tokiu būdu buvo sugeneruota ir atrinkta 10 sekų.
Po to algoritmas buvo vykdomas su atsitiktinai sugeneruota 15000 individų populiacija, dalį jos inicializuojant geriausiomis prieš tai gautomis sekomis
ir kiekvieną iteraciją pritaikant mutacijos ir rekombinacijos operatorius
atitinkamai $\frac{9}{10}$ ir $\frac{1}{100}$ populiacijos.
Tokiu būdu buvo sugeneruota ir atrinkta dar 10 sekų.
Galiausiai iš visų sugeneruotų sekų buvo atrinkta tinkamiausia.
Tai buvo atlikta sugeneruotas sekas naudojant 100000 atsitiktinai sugeneruotų masyvų rikiavimui
vadovėline Šelo rikiavimo algoritmo versija ir matuojant atliktų palyginimo operacijų aritmetinį vidurkį.
Atliekant matavimus taip pat buvo įtraukta Simpson ir Yachavaram pasiūlyta \cite{simpson1999faster} seka 1, 4, 13, 36, 83, 219, 893.
Tai buvo atlikta todėl, kad autorių teigimu tai sparčiausiai veikianti jų rasta galinė seka ir ji suteikė puikų kontekstą įvertinti
darbo metu sugeneruotų galinių sekų tinkamumą.
Geriausiai pasirodė seka 1, 5, 13, 40, 137, 669, 974.



\section{Sekų efektyvumo įvertinimas}
placeholder....

% \subsection{Poskyris}
% Citavimo pavyzdžiai nebereikalingi.

% \subsubsection{Skirsnis}
% \subsubsubsection{Straipsnis}
% \subsubsection{Skirsnis}
% \section{Skyrius}
% \subsection{Poskyris}
% \subsection{Poskyris}

\sectionnonum{Išvados}
Gavome tą ir aną, rekomenduojame šitai.
% Išvadose ir pasiūlymuose, nekartojant atskirų dalių apibendrinimų,
% suformuluojamos svarbiausios darbo išvados, rekomendacijos bei pasiūlymai.

\printbibliography[heading=bibintoc] % Literatūros šaltiniai

\appendix  % Priedai
% Prieduose gali būti pateikiama pagalbinė, ypač darbo autoriaus savarankiškai
% parengta, medžiaga. Savarankiški priedai gali būti pateikiami kompiuterio
% diskelyje ar kompaktiniame diske. Priedai taip pat vadinami ir numeruojami.
% Tekstas su priedais siejamas nuorodomis (pvz.: \ref{img:mlp}).

\section{Paveikslėlis}
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{img/MLP}
    \caption{Paveikslėlio pavyzdys}   % Antraštė įterpiama po paveikslėlio
    \label{img:mlp}
\end{figure}

\end{document}
