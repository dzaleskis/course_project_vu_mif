\documentclass{VUMIFInfKursinis}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{color}
\usepackage{graphicx}
\usepackage{hyperref}  % Nuorodų aktyvavimas
\usepackage{url}

\algnewcommand\algorithmicforeach{\textbf{foreach}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

% Titulinio aprašas
\university{Vilniaus universitetas}
\faculty{Matematikos ir informatikos fakultetas}
\institute{Informatikos institutas}  % Užkomentavus šią eilutę - institutas neįtraukiamas į titulinį
\department{Informatikos katedra}
\papertype{Kursinis darbas}
\title{Rikiavimo tobulinimas genetiniais algoritmais}
\titleineng{Improving sorting with genetic algorithms}
\status{3 kurso 2 grupės studentas}
\author{Deividas Zaleskis}
\supervisor{Irmantas Radavičius}
\date{Vilnius \\ \the\year}

% Nustatymai
\bibliography{bibliografija} 

\begin{document}
\maketitle

\tableofcontents

\sectionnonum{Įvadas}

Viena pagrindinių informatikos sąvokų yra algoritmas.
Formaliai algoritmą galima apibūdinti kaip
baigtinę seką instrukcijų, nurodančių kaip rasti nagrinėjamo uždavinio sprendinį.
Algoritmo koncepcija egzistuoja nuo senovės laikų \cite{knuth1972ancient}, tačiau atsiradus kompiuteriams,
tapo įmanoma algoritmų vykdymą automatizuoti, paverčiant juos mašininiu kodu suprantamu kompiuteriams \cite{wilkes1951preparation}.
Taip informatikos mokslas nuo teorinių šaknų \cite{turing1937computable} įgavo ir taikomąją pusę.
Beveik visus algoritmus galima suskirstyti į dvi klases: kombinatorinius algoritmus ir skaitinius algoritmus.
Skaitiniai algoritmai sprendžia tolydžius uždavinius: optimizuoti realaus argumento funkciją, išspręsti tiesinių lygčių sistemą su realiais koeficientais, etc.
Kombinatoriniai algoritmai sprendžia diskrečius uždavinius ir operuoja diskrečiais objektais: skaičiais, sąrašais, grafais, etc.
Vienas žinomiausių diskretaus uždavinio pavyzdžių yra duomenų rikiavimas.

Duomenų rikiavimas yra vienas pamatinių informatikos uždavinių.
Matematiškai jis formuluojamas taip:
duotai baigtinei palyginamų elementų sekai $S = (s_1, s_2, ..., s_n)$ pateikti tokį
kėlinį, kad pradinės sekos elementai būtų išdėstyti didėjančia (mažėjančia) tvarka \cite{Radavičius_Baranauskas_2013}.
Rikiavimo uždavinys yra aktualus nuo pat kompiuterių atsiradimo ir buvo laikomas vienu 
pagrindinių diskrečių uždavinių, kuriuos turėtų gebėti spręsti kompiuteris \cite{10.1145/356580.356581}.
Rikiavimo uždavinio sprendimas dažnai padeda pagrindą efektyviam kito uždavinio sprendimui,
pavyzdžiui, atliekant paiešką sąraše, galima taikyti dvejetainės paieškos algoritmą tik tada,
kai sąrašas yra išrikiuotas.
Kadangi rikiavimo uždavinys yra fundamentalus, jam spręsti egzistuoja labai skirtingų algoritmų.

Rikiavimo algoritmų yra įvairių:
paremtų palyginimu (elementų tvarką nustato naudojant palyginimo operatorius),
stabilių (nekeičia lygių elementų tvarkos),
nenaudojančių papildomos atminties (atminties sudėtingumas yra $O(1)$), etc.
Asimptotiškai optimalūs palyginimu paremti algoritmai blogiausiu atveju turi $O(n\,log\,n)$ laiko sudėtingumą,
o ne palyginimu paremti algoritmai gali veikti dar greičiau, tačiau nėra tokie universalūs, kadangi rikiuojama remiantis duomenų specifika.
Tiesa, rikiuojant remtis vien algoritmo asimptotika nepakanka:
rikiavimas įterpimu (angl. insertion sort) blogiausiu atveju turi $O(n^2)$ laiko sudėtingumą \cite{bender2006insertion},
tačiau mažesnius elementų kiekius rikiuoja daug greičiau, nei asimptotiškai optimalūs algoritmai,
pavyzdžiui, rikiavimas krūva (angl. heapsort) \cite{10.1145/512274.512284}.
Todėl pastaruoju metu plačiai naudojami hibridiniai rikiavimo algoritmai, kurie sujungia keletą rikiavimo
algoritmų į vieną ir panaudoja jų geriausias savybes.
Nepaisant įvairovės ir naujų algoritmų gausos, klasikiniai rikiavimo algoritmai išlieka aktualūs.

Šelo rikiavimo algoritmas (angl. Shellsort, toliau - Šelo algoritmas) \cite{10.1145/368370.368387} yra paremtas palyginimu, nenaudojantis papildomos atminties ir nestabilus.
Šelo algoritmą galima laikyti rikiavimo įterpimu modifikacija,
kuri lygina ne gretimus, o toliau vienas nuo kito esančius elementus, taip paspartindama jų perkėlimą į galutinę poziciją.
Pagrindinė algoritmo idėja - išskaidyti rikiuojamą seką S į posekius $S_1, S_2, ..., S_n$,
kur kiekvienas posekis $S_i = (s_i, s_{i+h}, s_{i+2h}, ...)$ yra sekos S elementai, kurių pozicija skiriasi $h$.
Išrikiavus visus sekos $S$ posekius $S_i$ su tarpu $h$, seka tampa $h$-išrikiuota.
Remiantis tuo, jog sekai S esant $h$-išrikiuota ir ją $k$-išrikiavus, ji lieka $h$-išrikiuota \cite{GALE1972103},
galima kiekvieną algoritmo iteraciją mažinti tarpą, taip vis didinant sekos $S$ išrikiuotumą.
Pritaikant šias idėjas ir rikiavimui naudojant mažėjančią tarpų seką su paskutiniu nariu $1$,
kuris garantuoja rikiavimą įterpimu paskutinėje iteracijoje,
galima užtikrinti, jog algoritmo darbo pabaigoje seka S bus pilnai išrikiuota.
Įvertinant Šelo algoritmo idėjas, nesunku pastebėti tarpų sekų įtaką jo veikimui.

Šelo algoritmo efektyvumas tiesiogiai priklauso nuo pasirinktos tarpų sekos.
Weiss atlikto tyrimo \cite{weiss1991short} rezultatai rodo, jog su Sedgewick pasiūlyta seka
šis algoritmas veikia beveik dvigubai greičiau nei Šelo pradinis variantas, kai $n = 1000000$.
Yra įrodyta, kad Šelo algoritmo laiko sudėtingumo blogiausiu atveju apatinė riba yra
$\Omega(\frac{n\,log^2\,n}{log\,log\,n^2})$ \cite{267769}, taigi jis nėra asimptotiškai optimalus.
Tiesa, kol kas nėra rasta seka, su kuria Šelo algoritmas pasiektų šią apatinę ribą.
Kiek žinoma autoriui, asimptotiškai geriausia tarpų seka yra rasta Pratt, kuri yra formos
$2^p3^p$ ir turi $\Theta(n\,log^2\,n)$ laiko sudėtingumą \cite{pratt1972shellsort},
tačiau praktikoje ji veikia lėčiau už Ciura \cite{ciura2001best} ar Tokuda \cite{10.5555/645569.659879} pasiūlytas sekas.
Daugelio praktikoje efektyvių sekų asimptotinis sudėtingumas laiko atžvilgiu lieka atvira problema,
nes jos yra rastos eksperimentiškai.
Vienas iš metodų, kuriuos galima taikyti efektyvių tarpų sekų radimui, yra genetinis algoritmas.

Genetinis algoritmas (GA) yra metodas rasti euristikas, paremtas biologijos žiniomis apie natūralios atrankos procesą.
Kartu su genetiniu programavimu, evoliuciniais algoritmais ir kitais metodais, % citations needed
genetiniai algoritmai sudaro evoliucinių skaičiavimų šeimą.
Visi šios šeimos atstovai yra paremti pradinės populiacijos generavimu ir iteraciniu populiacijos atnaujinimu naudojant biologijos įkvėptas strategijas.
J.H. Holland, GA pradininkas, savo knygoje \cite{holland1992adaptation}
apibrėžė genetinio algoritmo sąvoką ir su ja glaudžiai susijusias
chromosomų (potencialių uždavinio sprendinių, išreikštų genų rinkiniu), bei
rekombinacijos (tėvinių chromosomų genų perdavimo palikuonims),
atrankos (tinkamiausių chromosomų atrinkimo) ir mutacijos (savaiminio chromosomos genų kitimo) operatorių koncepcijas.
Genetinių algoritmų veikimo strategija pagrįsta pradinės chromosomų populiacijos evoliucija, kiekvienos naujos chromosomų kartos
gavimui naudojant rekombinacijos, atrankos ir mutacijos operatorius.
Toliau bus aptariamos genetinių algoritmų taikymo galimybės.

Genetiniai algoritmai taikomi sprendžiant įvairius paieškos ir optimizavimo uždavinius, kuomet nesunku nustatyti, ar sprendinys tinkamas,
tačiau tinkamo sprendinio radimas reikalauja daug resursų ar net pilno perrinkimo.
Tokiu atveju apytikslio sprendinio radimas (euristika) gali būti daug patrauklesnis sprendimo būdas,
kadangi tikslaus sprendinio radimas dažnai yra NP-sunkus uždavinys.
Todėl GA yra pritaikomi sudarant grafikus ir tvarkaraščius,
sprendžiant globalaus optimizavimo uždavinius
ir net projektuojant NASA mikrosatelitų antenas \cite{hornby2006automated}.
Nesunku pastebėti, jog efektyvių Šelo algoritmo tarpų sekų radimas yra sunkus uždavinys atliekamų skaičiavimų prasme,
tikėtinai reikalaujantis pilno potencialių sprendinių perrinkimo,
tad šio uždavinio sprendimui taikyti GA yra prasminga.
Kiek žinoma autoriui, kol kas yra buvę du bandymai taikyti genetinius algoritmus efektyvių Šelo algoritmo tarpų sekų radimui \cite{simpson1999faster, roos2002genetic}.
Abiejuose darbuose teigiama, jog genetiniais algoritmais gautos tarpų sekos veikia greičiau už Sedgewick seką, kuri literatūroje laikoma viena efektyviausių.

\pagebreak

Darbo \textbf{tikslas}:
pritaikyti genetinius algoritmus Šelo algoritmo tarpų sekoms generuoti.

Darbo uždaviniai:
\begin{itemize}
  \item Atlikti Šelo rikiavimo algoritmo literatūros analizę.
  \item Nustatyti kriterijus tarpų sekų efektyvumui įvertinti.
  \item Paruošti aplinką eksperimentų vykdymui.
  \item Naudojant genetinius algoritmus sugeneruoti tarpų sekas.
  \item Atliekant eksperimentus įvertinti sugeneruotų ir pateiktų literatūroje tarpų sekų efektyvumą.
\end{itemize}

Šis darbas sudarytas iš 6 skyrių.
Pirmame skyriuje atliekama Šelo rikiavimo algoritmo literatūros analizė.
Antrame skyriuje apžvelgiama genetinio algoritmo sąvoka.
Trečiame skyriuje nustatomi kriterijai tarpų sekų efektyvumui įvertinti.
Ketvirtame skyriuje paruošiama eksperimentų vykdymo aplinka.
Penktame skyriuje generuojamos tarpų sekos, naudojant genetinius algoritmus.
Šeštame skyriuje atliekant eksperimentus įvertinamas sugeneruotų ir pateiktų literatūroje tarpų sekų efektyvumas.

\section{Šelo rikiavimo algoritmas}

\subsection{Šelo rikiavimo algoritmo efektyvumas}

\subsubsection{Šelo rikiavimo algoritmo asimptotinė analizė}

\subsubsection{Šelo rikiavimo algoritmo efektyvumas priklausomai nuo duomenų dydžio}

Renkantis kokį algoritmą naudoti, labai svarbu įvertinti tikėtiną duomenų dydį.
Šelo rikiavimo algoritmas yra efektyviausias, kai duomenų dydis yra ganėtinai mažas \cite{ciura2001best}.
Kaip teigiama \cite{simpson1999faster}, šis algoritmas veikia geriausiai, kai $N \simeq 106$.
Tokiu atveju, jis lenkia net ir vienu greičiausių laikomą greitojo rikiavimo algoritmą.
Todėl Šelo rikiavimo algoritmas dažnai naudojamas hibridiniuose rikiavimo algoritmuose, kai pasiekus tam tikrą rekursijos lygį
rikiuojamų duomenų dalis tampa pakankamai maža ir tolimesnė rekursija asimptotiškai optimaliu algoritmu nebeturi prasmės,
kadangi jos tęsimas reikalautų per daug mašinos resursų.
Tokių šio algoritmo naudojimo pavyzdžių galima rasti Go programavimo kalbos standartinėje bibliotekoje \cite{golangsort} bei
bzip2 failų glaudinimo programoje \cite{bzip2sort}.
Tiesa, net ir rikiuojant didesnius duomenų dydžius, Šelo algoritmas nėra labai lėtas \cite{ciura2001best}.
Todėl jis yra vertingas įrankis įgyvendinant operacinės sistemos branduolį ar programuojant įterptinėms sistemoms, kadangi dėl ribotų atminties išteklių
asimptotiškai optimalūs algoritmai, kurie dažniausia yra rekursyvūs ir naudoja daugiau atminties, tokiais atvejais netinka.
Taigi, nors Šelo rikiavimo algoritmas nėra vienas greičiausių kai uždavinys didelis,
yra scenarijų, kuriais šį algoritmą rinktis tikrai verta.

\subsubsection{Šelo rikiavimo algoritmo efektyvumas priklausomai nuo duomenų specifikos}

Viena palankiausių Šelo algoritmo savybių yra jo adaptyvumas.
Adaptyvumas rikiavimo algoritmų kontekste reiškia, jog algoritmas atlieka mažiau operacijų, jei duomenys dalinai išrikiuoti.
Adaptyvumą Šelo algoritmas paveldi iš rikiavimo įterpimu, nes yra jo optimizacija.
Verta pastebėti, jog Šelo algoritmas būtent šia savybe ir remiasi rikiavimo įterpimu optimizavimui:
kadangi rikiavimas įterpimu veikia labai greitai, kai duomenys išrikiuoti (tokiu atveju sudėtingumas laiko atžvilgiu yra $O(n)$),
duomenis pradžioje h-išrikiavus, paskutine iteracija taikomas rikiavimas įterpimu veikia daug greičiau.
Moksliniuose tyrimuose ši savybė retai turi įtakos, kadangi dažniausia siekiama ištirti algoritmo veikimą, kai duomenys
nėra tvarkingai išdėstyti ir tipiškai renkamasi atsitiktinai generuoti pradinius duomenis šiam tikslui pasiekti.
Savaime aišku, jog praktikoje retai pavyks sutikti visiškai atsitiktinai išsidėsčiusius duomenis, neturinčius nei vieno išrikiuoto posekio ilgesnio nei 1.
Kaip praktinį šios idėjos taikymo pavyzdį galima pateikti vieną populiariausių šiuo metu naudojamų algoritmų, Timo rikiavimo algoritmą (angl. Timsort) \cite{auger2018worst}. 
Timo rikiavimo algoritmas remiasi tuo, jog realiame pasaulyje sutinkami duomenys labai dažnai turi išrikiuotų posekių,
o juos aptikus rikiavimą galima atlikti greičiau, kadangi šių posekių rikiuoti nebereikia.
Kaip parodo \cite{10.1145/359024.359026}, Šelo algoritmas veikia net keletą kartų greičiau, kai duomenys yra pilnai
išrikiuoti ir veikimo sparta nusileidžia tik rikiavimui įterpimu su visais duomenų dydžiais.
Kai duomenų dydis nedidelis (iki 200 elementų) ir 20\% elementų nėra teisingose pozicijose, Šelo algoritmas veikimo sparta nusileidžia tik greitojo rikiavimo algoritmui.
Palankūs rezultatai pateikiami ir \cite{7280062} - su dalinai išrikiuotais duomenimis Šelo algoritmas veikia apytiksliai $1.5$ karto greičiau, o su išrikiuotais
duomenimis pasiekiamas apie $3.8$ karto mažesnis veikimo greitis.
Taigi, rikiuojant dalinai išrikiuotus duomenis Šelo algoritmas yra labai efektyvus.

\subsection{Šelo rikiavimo algoritmo versijos}

\subsubsection{Vadovėlinis Šelo rikiavimo algoritmas}

Kaip ir daugelis algoritmų, Šelo rikiavimo algoritmas turi keletą galimų implementacijų.
Žinomiausia iš jų, be abejo, yra vadovėlinė šio algoritmo versija,
daugeliui pasaulio informatikos studentų žinoma iš duomenų struktūrų ir algoritmų kurso.
Jos pseudokodas pateikiamas žemiau.

\begin{algorithm}[H]
  \caption{Vadovėlinis Šelo rikiavimo algoritmas}\label{alg:tss}
  \begin{algorithmic}[1]
  \ForEach {$gap$ \textbf{in} $H$}
    \For {$i\gets gap+1$ \textbf{to} $N$}
      \State $j\gets i$
      \State $temp\gets S[i]$\label{alg:tss:assign1}
      \While {$j > gap$ \textbf{and} $S[j - gap] > S[j]$}\label{alg:tss:while:start}
        \State $S[j]\gets S[j - gap]$
        \State $j\gets j-gap$
      \EndWhile\label{alg:tss:while:end}
      \State $S[j]\gets temp$\label{alg:tss:assign2}
    \EndFor
  \EndFor
  \end{algorithmic}
\end{algorithm}

\subsubsection{Patobulintas Šelo rikiavimo algoritmas}

Verta pastebėti, jog vadovėlinė Šelo algoritmo implementacija nėra naši \cite{Radavičius_Baranauskas_2013}.
Vykdant vidinį vadovėlinio Šelo algoritmo ciklą (\algref{alg:tss}{alg:tss:while:start} - \algref{alg:tss}{alg:tss:while:end} eilutės),
\algref{alg:tss}{alg:tss:while:start} eilutėje yra tikrinama, ar $S[j]$ jau yra tinkamoje pozicijoje.
Jei $S[j]$ jau yra tinkamoje pozicijoje, vidinis ciklas nėra vykdomas ir jokių elementų pozicijos nėra keičiamos.
Tačiau \algref{alg:tss}{alg:tss:assign1} ir \algref{alg:tss}{alg:tss:assign2} eilutėse vis tiek yra vykdomi du priskyrimai,
kurie šiuo atveju nueina veltui (o taip nutinka pakankamai dažnai).
Siekiant tai ištaisyti, \cite{Radavičius_Baranauskas_2013} pateikė patobulintą Šelo algoritmo versiją, kuri prieš vykdydama
bet kokias kitas instrukcijas patikrina, ar elementas $S[j]$ jau yra tinkamoje pozicijoje.
Patobulinto Šelo algoritmo pseudokodas pateikiamas žemiau.

\begin{algorithm}[H]
  \caption{Patobulintas Šelo rikiavimo algoritmas}\label{alg:iss}
  \begin{algorithmic}[1]
  \ForEach {$gap$ \textbf{in} $H$}
    \For {$i\gets gap+1$ \textbf{to} $N$}
      \If {$S[i-gap] > S[i]$}
        \State $j\gets i$
        \State $temp\gets S[i]$
        \Repeat
          \State $S[j]\gets S[j - gap]$
          \State $j\gets j-gap$
        \Until {$j \le gap$ or $S[j - gap] \le S[j]$}
        \State $S[j]\gets temp$
      \EndIf
    \EndFor
  \EndFor
  \end{algorithmic}
\end{algorithm}

\section{Genetiniai algoritmai}

Prieš pradedant generuoti sekas, reikalinga plačiau apžvelgti genetinio algoritmo sąvoką.
Paprasčiausias genetinis algoritmas susideda iš chromosomų populiacijos bei atrankos, mutacijos ir rekombinacijos operatorių.
Projektuojant genetinį algoritmą tam tikro uždavinio sprendimui, svarbu tinkamai pasirinkti,
kaip kompiuteriu modeliuoti galimus sprendinius (chromosomas).
Chromosomos kompiuterio atmintyje standartiškai išreiškiamos bitų eilutėmis,
kadangi tai palengvina tiek mutaciją (pakanka apversti kurio nors atsitiktinio bito reikšmę),
tiek rekombinaciją (pakanka perkopijuoti pasirinktus tėvinių chromosomų bitus į vaikinę chromosomą).
Tiesa, tai nėra vienintelis įmanomas būdas, ir kai kurių uždavinių sprendiniai modeliuojami pvz. grafu ar simbolių eilute.
Chromosomų rinkinys, literatūroje dažnai vadinamas populiacija, atspindi uždavinio sprendinių aibę, kuri kinta kiekvieną algoritmo iteraciją.
Sprendinio kokybę įvardijame kaip jo tinkamumą, kuris apibrėžiamas tinkamumo funkcijos reikšme, pateikus sprendinį kaip parametrą.
Nesunku pastebėti, jog tinkamumo funkcija tėra tikslo funkcijos specializacija, kuri naudojama chromosomų vertinimui.
Tinkamumo funkcija yra viena svarbiausių genetinio algoritmo dalių,
kadangi kai ji netinkamai parinkta, algoritmas nekonverguos į tinkamą sprendinį arba užtruks labai ilgai.  
Genetinis algoritmas vykdymo metu iteratyviai atnaujina esamą populiaciją, kurdamas naujas kartas taikant atrankos, rekombinacijos ir mutacijos operatorius.
Atrankos operatorius grąžina tinkamiausius populiacijos individus, kuriems yra leidžiama susilaukti palikuonių taikant rekombinacijos operatorių.
Rekombinacijos operatorius veikia iš dviejų tėvinių chromosomų sukurdamas naują vaikinę chromosomą, kas dažniausiai pasiekiama
tam tikru būdu perkopijuojant tėvų genų atkarpas į vaikinę chromosomą.
Rekombinacijos strategijų yra įvairių, tačiau ne kiekvienam uždaviniui visos jos tinka, kadangi
kai kuriais atvejais netinkamai parinkta rekombinacijos strategija pagamina neatitinkančią uždavinio apribojimų vaikinę chromosomą.
Pavyzdžiui, jei modeliuojama chromosoma yra sąrašas, turintis susidėti iš tam tikrų elementų, neįmanoma garantuoti, jog atsitiktinai
perkopijavus tėvinių chromosomų genus į vaikinę chromosomą šis apribojimas bus išlaikytas.
Galiausiai tam tikrai populiacijos daliai yra pritaikomas mutacijos operatorius.
Jo veikimo principas yra gana paprastas: pasirinktos chromosomos vienas ar keli genai yra modifikuojami,
nežymiai pakeičiant jų reikšmes ar sukeičiant kelių genų reikšmes vietomis.
Mutacijos operatorius praplečia vykdomos paieškos erdvę, o tai labai svarbu, kadangi kitaip algoritmas gali konverguoti
į lokaliojo minimumo taškus, taip ir nepasiekdamas globaliojo minimumo.
Atsižvelgiant į tai, yra laikoma, jog mutacijos operatorius yra kertinė genetinio algoritmo dalis,
kuri palaiko genetinę individų įvairovę ir padeda rasti tinkamiausius sprendinius.
Jei algoritmas suprojektuotas tinkamai, dažnu atveju vidutinis populiacijos tinkamumas gerės kiekvieną iteraciją.
Kad algoritmas neveiktų amžinai, yra pasirenkama tam tikra sustojimo sąlyga, pvz. pasiektas maksimalus
kartų skaičius, vidutinio tinkamumo pokytis tarp paskutinių dviejų populiacijos kartų pakankamai mažas.


\subsection{Galima paprasto genetinio algoritmo implementacija}

Apjungiant visas aukščiau aptartas genetinio algoritmo dalis, galima suformuluoti paprasto genetinio algoritmo pseudokodą.

\begin{algorithm}[H]
  \caption{Paprastas GA}\label{simple_GA}
  \begin{algorithmic}
    \State Let $current\_population$ be a random population of chromosomes.
    \State Let $mutation\_rate$ be a real value between 0 and 1.
    \State Let $recombination\_fraction$ be a real value between 0 and 1.
    \Repeat
      \State Apply the fitness function to each chromosome in $current\_population$.
      \State Sort the chromosomes in $current\_population$ based on their fitness.
      \State Let $new\_population$ be an empty set.
      \Repeat
        \State Let $(parent1, parent2)$ be a pair of parent chromosomes selected randomly from the first $[N * recombination\_fraction]$ elements of $current\_population$.
        \State Let $child\_chromosome$ be the result of applying the recombination operator to $parent1$ and $parent2$.
        \State Let $rand$ be a random real value between 0 and 1.
        \If {$rand < mutation\_rate$}
          \State Apply the mutation operator to $child\_chromosome$
        \EndIf
        \State Add $child\_chromosome$ to $new\_population$
      \Until N offspring have been created.
      \State Assign $new\_population$ to $current\_population$.
    \Until termination criteria are satisfied.
  \end{algorithmic}
\end{algorithm}

\section{Tarpų sekų efektyvumo kriterijų nustatymas}

Šelo algoritmo tarpų sekų efektyvumo įvertinimas nėra trivialus.
Rikiavimo algoritmai dažniausiai yra vertinami pagal atliekamų priskyrimų skaičių.
Skaičiuojant algoritmo atliekamus priskyrimus, gana paprasta jais išreikšti inversijų skaičių. % o kodel inversijos svarbu?
Daugelyje algoritmų priskyrimų skaičius uždaviniui augant greitai artėja prie palyginimų skaičiaus,
tad tokiu metodu gautas įvertis būna pakankamai tikslus.
Šelo algoritmo atveju, vien priskyrimų skaičius nėra pakankamai tikslus kriterijus tarpų sekų efektyvumui įvertinti,
kadangi remiantis tik juo, gautas įvertis neatspindi praktinio efektyvumo.
Kaip parodo \cite{ciura2001best}, šiame algoritme dominuojanti operacija yra palyginimas.
Tad galima daryti išvadą, jog atliekamų palyginimų skaičius yra tinkamesnis kriterijus efektyvumui įvertinti.

Matuojant rikiavimo algoritmo efektyvumą tik naudojant sveikaskaitinius pradinius duomenis, gauti rezultatai gali būti netikslūs,
kadangi šių operacijų sparta priklauso nuo rikiuojamų duomenų tipo.
Rikiuojant simbolių eilutes, priskyrimas atliekamas naudojant rodykles, kas yra $O(1)$ operacija,
tačiau palyginimas yra $O(n)$ blogiausiu atveju.
Ir atvirkščiai, rikiuojant įrašus kurie saugomi steke, priskyrimas reikalauja perkopijuoti visą įrašą,
o palyginimas gali būti atliekamas naudojant tam tikrą raktą.
Todėl apsiriboti vien palyginimų ar priskyrimų skaičiumi nepakanka, kadangi tiksliausia praktinio algoritmo
veikimo laiko aproksimacija (tai, kam ir skaičiuojamos operacijos), bus gauta tik įvertinant abu šiuos rodiklius.

Algoritmo veikimo laikas, nors ir priklausomas nuo platformos, kurioje vykdomas tyrimas, detalių,
taip pat gali duoti tinkamų įžvalgų įvertinant praktinį efektyvumą.
Kadangi algoritmo atliekamos operacijos skaičiuojamos tam, jog gauti praktinio
veikimo laiko aproksimaciją, tai realus veikimo laikas
yra konkretus įvertis, leidžiantis praktiškai įvertinti duotos sekos efektyvumą.
Taigi, įvertinant tarpų sekų efektyvumą bus remiamasi visomis atliekamomis operacijomis bei realiais veikimo laikais.

\section{Eksperimentų vykdymo aplinkos paruošimas}

\subsection{Techninės detalės}
Tyrimui buvo naudotas kompiuteris su 2.70 GHz Intel(R) Core(TM) i7-10850H procesoriumi,
32 GB operatyviosios atminties ir Windows 10 operacine sistema.
Tyrimas buvo įgyvendintas C++ kalba su GNU g++ 8.1.0 kompiliatoriumi.
Genetinio algoritmo implementacijai buvo pasirinkta OpenGA biblioteka \cite{mohammadi2017openga}
dėl suteikiamos laisvės pasirinkti, kaip įgyvendinti genetinius operatorius bei modernių kalbos konstruktų ir lygiagretaus vykdymo palaikymo.

\subsection{Pasiruošimas matavimų atlikimui}

\subsubsection{Operacijas skaičiuojantis vadovėlinis Šelo algoritmas}

Siekant išmatuoti vadovėlinio Šelo algoritmo atliekamų operacijų skaičių,
buvo parengtas \ref{alg:tss_reported} algoritmas, kuris kaip rezultatą grąžina atliktus palyginimus bei priskyrimus.

\subsubsection{Operacijas skaičiuojantis patobulintas Šelo algoritmas}

Siekant išmatuoti patobulinto Šelo algoritmo atliekamų operacijų skaičių,
buvo parengtas \ref{alg:iss_reported} algoritmas, kuris kaip rezultatą grąžina atliktus palyginimus bei priskyrimus.

\subsubsection{Veikimo laiko matavimas}

Verta pastebėti, jog matuoti veikimo laiką naudojant \ref{alg:tss_reported} ir \ref{alg:iss_reported} algoritmus nėra tinkama,
kadangi jie skaičiuodami atliekamas operacijas vykdo papildomus žingsnius, o tai gali iškreipti gautus rezultatus.
Atsižvelgiant į tai, veikimo laiko matavimui naudoti \ref{alg:tss} ir \ref{alg:iss} algoritmai. 

\section{Tarpų sekų generavimas}

\subsection{Trumpų tarpų sekų generavimas}
Pirmame etape buvo generuojamos tarpų sekos, kurios efektyvios kai $N=1000$.
Remiantis \cite{simpson1999faster}, trumpos sekos chromosoma buvo modeliuojama kaip
septynių sveikų skaičių masyvas.
Trumpų sekų generavimui buvo paruoštas vienkriterinis genetinis algoritmas.
Chromosomos buvo vertinamos jas naudojant 20-ties atsitiktinai
sugeneruotų sveikų skaičių masyvų rikiavimui vadovėline Šelo rikiavimo algoritmo versija ir skaičiuojant atliktas palyginimo operacijas.
Chromosomos tinkamumo funkcija buvo apibrėžta kaip atliktų palyginimų skaičiaus aritmetinis vidurkis.
Rekombinacijos operatorius buvo įgyvendintas tolygia strategija, kur abiejų tėvų genai turi vienodą tikimybę
būti perduoti vaikinei chromosomai.
Mutacijos operatorius buvo įgyvendintas su $\frac{1}{5}$ tikimybe keičiant tam tikrą chromosomą,
pridedant prie atsitiktinai pasirinkto geno reikšmės skaičių $(rand()-rand())*25*\frac{2}{10*\sqrt{kartos\_numeris}}$ su apribojimu, jog pakeistas genas turi priklausyti intervalui $[1, 1000]$.
Siekiant išvengti netinkamų sprendinių, kiekviena seka po rekombinacijos ar mutacijos operatorių taikymo buvo išrikiuojama ir
užtikrinama, jog paskutinis sekos narys yra $1$.

Algoritmas buvo vykdomas su atsitiktinai sugeneruota 10000 individų populiacija, kiekvieną iteraciją pritaikant rekombinacijos operatorių
$\frac{1}{2}$ populiacijos.
Tokiu būdu buvo sugeneruota ir atrinkta 10 sekų.
Po to iš visų sugeneruotų sekų buvo atrinkta tinkamiausia, sugeneruotas sekas naudojant 10000 atsitiktinai sugeneruotų masyvų ilgio 1000 rikiavimui
ir matuojant atliktų palyginimo operacijų aritmetinį vidurkį.
Atlikus matavimus, buvo pasirinkta seka $855, 264, 86, 35, 12, 5, 1$.

\subsection{Vidutinio ilgio tarpų sekų generavimas}
Antrame etape buvo generuojamos tarpų sekos, kurios efektyvios kai $N=100000$.
Vidutinio ilgio sekų generavimui buvo pasitelktas modifikuotas genetinis algoritmas, naudotas generuojant trumpas tarpų sekas.
Tarpų sekos chromosoma buvo modeliuojama kaip sveikų skaičių masyvas ilgio 12.
Buvo atsisakyta chromosomų vertinimo naudojant 20 skirtingų masyvų, kadangi tai darė neigiamą įtaką genetinio algoritmo veikimo laikui.
Vietoje to, kiekvienos sekos vertinimui buvo naudojami 5 atsitiktinai sugeneruoti masyvai ilgio $100000$.
Mutacijos operatorius buvo pakoreguotas ir su $\frac{1}{5}$ tikimybe keitė tam tikrą chromosomą,
pridedant prie atsitiktinai pasirinkto geno reikšmės skaičių $(rand()-rand())*75*\frac{2}{10*\sqrt{kartos\_numeris}}$.
% pridek apie kartas

Algoritmas buvo vykdomas su atsitiktinai sugeneruota 1000 individų populiacija,
paskutinius septynis chromosomos genus inicializuojant elementais $855, 264, 86, 35, 12, 5, 1$, t.y. sekos, gautos pirmame etape, nariais.
Siekiant išlaikyti tinkamiausius sprendinius, buvo pasitelktas elitizmas - geriausiai pasirodžiusios 75 chromosomos nekeistos
patekdavo į kitą algoritmo iteraciją.
Rekombinacijos operatorius buvo taikomas $\frac{1}{2}$ populiacijos kiekvieną algoritmo iteraciją.
Tokiu būdu buvo sugeneruota ir atrinkta 10 sekų.
Po to iš visų sugeneruotų sekų buvo atrinkta tinkamiausia, sugeneruotas sekas naudojant 1000 atsitiktinai sugeneruotų masyvų ilgio 100000 rikiavimui
ir matuojant atliktų palyginimo operacijų aritmetinį vidurkį.
Atlikus matavimus, buvo pasirinkta seka $45794, 17396, 7414, 3136, 1206, 561, 264, 86, 35, 12, 5, 1$.

\section{Tarpų sekų efektyvumo įvertinimas}

\subsection{Pasiruošimas tarpų sekų vertinimui}

Iš anksto verta pastebėti, jog ne visos šiame skyriuje tiriamos tarpų sekos iš tiesų yra būtent tokio ilgio, koks pateikiamas šiame darbe.
Tačiau būtina atsižvelgti į faktą, jog tai galėtų sukelti nelygias sąlygas atliekamuose matavimuose,
kadangi seka, turinti elementų didesnių už maksimalų tiriamą $N$, atliktų nereikalingas operacijas, o per trumpa seka veiktų neefektyviai.
Siekiant standartizuoti tarpų sekų ilgius, buvo pasirinkta kai kurias sekas sutrumpinti (ar pratęsti, jei tam yra žinoma rekursyvi formulė)
taip, jog standartizuota seka būtų ilgiausia įmanoma seka, kurios visi elementai mažesni už maksimalų tiriamą $N$.
Atliekamų matavimų skaičius buvo pasirinktas atsižvelgiant į tame etape tiriamo $N$ dydį: jei $N$ labai mažas,
egzistuoja didelė tikimybė jog gautas vidutinis įvertis bus netikslus, matuojant, pavyzdžiui, tik 1000 kartų.
Todėl tiriant trumpesnes sekas buvo stengtasi atlikti daugiau matavimų.

\subsection{Trumpų tarpų sekų efektyvumo įvertinimas}
Trumpų tarpų sekų efektyvumo tyrimui buvo pasirinktos šios tarpų sekos:
\begin{itemize}
  \item Tokuda: $525,233,103,46,20,9,4,1$
  \item Ciura: $701,301,132,57,23,10,4,1$
  \item Simpson-Yachavaram: $893,219,83,36,13,4,1$
  \item Sedgewick: $929,505,209,109,41,19,5,1$
  \item Incerpi-Sedgewick: $861,336,112,48,21,7,3,1$
  \item Trumpa seka: $855,264,86,35,12,5,1$
\end{itemize}
Tokuda \cite{10.5555/645569.659879} seka buvo pasirinkta atsižvelgiant į tai, jog praktikoje ji laikoma viena efektyviausių.
Kiek žinoma autoriui, kai $N=1000$ Ciura \cite{ciura2001best} seka atlieka mažiausiai palyginimų vidutiniu atveju, tad ją buvo būtina įtraukti.
Simpson ir Yachavaram \cite{simpson1999faster} seka buvo pasirinkta, kadangi pasak autorių,
tai geriausiai veikianti jų rasta seka, kai $N=1000$.
Sedgewick \cite{SEDGEWICK1986159} ir Incerpi-Sedgewick \cite{incerpi1985improved} sekos pasirinktos dėl tvirto matematinio pagrindo
(įrodytas $O(n^\frac{4}{3})$ sudėtingumas blogiausiu atveju) bei fakto, jog ilgą laiką šios sekos buvo laikomos vienomis efektyviausių.

\subsubsection{Trumpų tarpų sekų efektyvumo įvertinimas naudojant vadovėlinį Šelo algoritmą}
matavimai atlikti 50000 kartu. laikas mikrosekundem.

\begin{table}[H]
  \caption{Vidutinis vadovėlinio Šelo algoritmo atliekamų palyginimų skaičius naudojant trumpas tarpų sekas}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda  & Ciura   & S/Y     & Sedgewick & I/S     & TS      \\ \hline
  50   & 289.902 & 287.76  & 287.704 & 293.414   & 296.373 & 289.207 \\ \hline
  100  & 735.822 & 733.353 & 731.492 & 752.139   & 759.577 & 731.877 \\ \hline
  200  & 1812.59 & 1797.92 & 1798.5  & 1840.15   & 1870.94 & 1793.19 \\ \hline
  400  & 4315.6  & 4276.38 & 4284.94 & 4405.07   & 4464.59 & 4273.84 \\ \hline
  800  & 10061.3 & 9946.54 & 9987.18 & 10260.5   & 10528.2 & 9999.9  \\ \hline
  1000 & 13128.9 & 13044.4 & 13075.4 & 13395.4   & 13807.4 & 13054.4 \\ \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \caption{Vidutinis vadovėlinio Šelo algoritmo atliekamų priskyrimų skaičius naudojant trumpas tarpų sekas}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda  & Ciura   & S/Y     & Sedgewick & I/S     & TS      \\ \hline
  50   & 482.372 & 473.174 & 453.477 & 447.686   & 487.444 & 456.583 \\ \hline
  100  & 1204.5  & 1186.33 & 1137.21 & 1130.61   & 1227.55 & 1135.35 \\ \hline
  200  & 2933.02 & 2862.17 & 2752.73 & 2761.21   & 2977.03 & 2745.81 \\ \hline
  400  & 6898.23 & 6733.29 & 6522.93 & 6629.27   & 6903.13 & 6444.15 \\ \hline
  800  & 15899.2 & 15487.9 & 14758.6 & 15354.8   & 15950   & 14745.8 \\ \hline
  1000 & 20707.8 & 20273.4 & 19200.7 & 20089.7   & 20841.4 & 19193.6 \\ \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \caption{Vidutinis vadovėlinio Šelo algoritmo veikimo laikas naudojant trumpas tarpų sekas}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda  & Ciura   & S/Y     & Sedgewick & I/S     & TS      \\ \hline
  50   & 0.99916 & 1.02294 & 1.0962  & 1.00912   & 1.13534 & 0.8968  \\ \hline
  100  & 3.03872 & 2.87242 & 2.74936 & 2.9471    & 2.74198 & 3.09066 \\ \hline
  200  & 6.34908 & 6.24564 & 6.32294 & 6.00468   & 7.19932 & 6.37474 \\ \hline
  400  & 16.3897 & 15.0581 & 14.2942 & 14.2024   & 14.7652 & 14.9239 \\ \hline
  800  & 39.9326 & 37.5984 & 35.4103 & 38.5972   & 43.2178 & 33.2975 \\ \hline
  1000 & 45.7384 & 44.2994 & 42.0728 & 42.58     & 44.4423 & 44.0977 \\ \hline
  \end{tabular}
\end{table}

\subsubsection{Trumpų tarpų sekų efektyvumo įvertinimas naudojant patobulintą Šelo algoritmą}

\begin{table}[H]
  \caption{Vidutinis patobulinto Šelo algoritmo atliekamų palyginimų skaičius naudojant trumpas tarpų sekas}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda  & Ciura   & S/Y     & Sedgewick & I/S     & TS      \\ \hline
  50   & 289.845 & 287.85  & 287.829 & 293.697   & 296.326 & 289.093 \\ \hline
  100  & 736.166 & 733.319 & 731.699 & 751.94    & 759.466 & 732.012 \\ \hline
  200  & 1812.48 & 1798.04 & 1798.66 & 1840.66   & 1871.29 & 1793.03 \\ \hline
  400  & 4315.89 & 4276.2  & 4284.83 & 4405.79   & 4464.4  & 4273.78 \\ \hline
  800  & 10061   & 9945.74 & 9986.13 & 10259.8   & 10525.9 & 9999.26 \\ \hline
  1000 & 13130.8 & 13044.1 & 13077.2 & 13393     & 13807.5 & 13053.1 \\ \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \caption{Vidutinis patobulinto Šelo algoritmo atliekamų priskyrimų skaičius naudojant trumpas tarpų sekas}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda  & Ciura   & S/Y     & Sedgewick & I/S     & TS      \\ \hline
  50   & 312.134 & 319.661 & 322.804 & 335.367   & 322.303 & 323.758 \\ \hline
  100  & 791.061 & 797.726 & 811.354 & 853.821   & 822.163 & 814.179 \\ \hline
  200  & 1931.99 & 1919.31 & 1999.55 & 2061.03   & 1998.26 & 1996.21 \\ \hline
  400  & 4537.96 & 4545.12 & 4731.2  & 4855.45   & 4767.84 & 4720.75 \\ \hline
  800  & 10502.1 & 10587.7 & 11134.9 & 11121.3   & 11396.8 & 11222.5 \\ \hline
  1000 & 13866.1 & 13819.4 & 14510.7 & 14523.7   & 14868.7 & 14490.7 \\ \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \caption{Vidutinis patobulinto Šelo algoritmo veikimo laikas naudojant trumpas tarpų sekas}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda  & Ciura   & S/Y     & Sedgewick & I/S     & TS      \\ \hline
  50   & 1.29704 & 1.259   & 1.01568 & 1.3169    & 1.31708 & 1.13992 \\ \hline
  100  & 3.15892 & 3.16134 & 3.13634 & 3.01816   & 3.35856 & 3.21644 \\ \hline
  200  & 7.53994 & 7.9495  & 7.53608 & 7.60948   & 8.1127  & 7.99592 \\ \hline
  400  & 18.519  & 18.9963 & 17.6689 & 17.292    & 18.9244 & 18.1828 \\ \hline
  800  & 42.9637 & 42.603  & 41.8065 & 40.6671   & 42.2326 & 41.1908 \\ \hline
  1000 & 56.6868 & 56.883  & 53.3879 & 53.4454   & 56.3774 & 52.8437 \\ \hline
  \end{tabular}
\end{table}

\subsection{Vidutinio ilgio tarpų sekų efektyvumo įvertinimas}

Vidutinio ilgio tarpų sekų efektyvumo tyrimui buvo pasirinktos šios tarpų sekos:
\begin{itemize}
  \item Tokuda: $68178,30301,13467,5985,2660,1182,525,233,103,46,20,9,4,1$
  \item Ciura: $90927,40412,17961,7983,3548,1577,701,301,132,57,23,10,4,1$
  \item Simpson-Yachavaram: $38291,22927,8992,3568,1488,893,219,83,36,13,4,1$
  \item Incerpi-Sedgewick: $86961,33936,13776,4592,1968,861,336,112,48,21,7,3,1$
  \item Sedgewick: $64769,36289,16001,8929,3905,2161,929,505,209,109,41,19,5,1$
  \item Roos-Bennet-Hannon-Zehner: $91433,72985,13229,5267,2585,877,155,149,131,23,8,1$
  \item Vidutinio ilgio seka: $45794,17396,7414,3136,1206,561,264,86,35,12,5,1$
\end{itemize}

\sectionnonum{Išvados}
Gavome tą ir aną, rekomenduojame šitai.
% Išvadose ir pasiūlymuose, nekartojant atskirų dalių apibendrinimų,
% suformuluojamos svarbiausios darbo išvados, rekomendacijos bei pasiūlymai.

\printbibliography[heading=bibintoc] % Literatūros šaltiniai

\appendix  % Priedai
% Prieduose gali būti pateikiama pagalbinė, ypač darbo autoriaus savarankiškai
% parengta, medžiaga. Savarankiški priedai gali būti pateikiami kompiuterio
% diskelyje ar kompaktiniame diske. Priedai taip pat vadinami ir numeruojami.
% Tekstas su priedais siejamas nuorodomis (pvz.: \ref{img:mlp}).

\section{Operacijas skaičiuojantis vadovėlinis Šelo algoritmas}
% \begin{algorithm}[H]
%   \caption{Operacijas skaičiuojantis vadovėlinis Šelo algoritmas}
%   \label{alg:tss_reported}
%   \begin{algorithmic}[1]
%   \State $cmp\gets 0$; $asn\gets 0$;
%   \ForEach {$gap$ \textbf{in} $H$}
%     \For {$i\gets gap+1$ \textbf{to} $N$}
%       \State $j\gets i$; $temp\gets S[i]$;
%       \State $cmp\gets cmp+1$; $asn\gets asn+2$;
%       \While {$j > gap$  \textbf{and} $S[j - gap] > S[j]$}
%         \State $S[j]\gets S[j - gap]$;
%         \State $j\gets j-gap$;
%         \State $asn\gets asn+2$; $cmp\gets cmp+2$;
%       \EndWhile
%       \If {$j < gap$}
%         \State $cmp\gets cmp+1$;
%       \Else
%         \State $cmp\gets cmp+2$;
%       \EndIf
%       \State $S[j]\gets temp$;
%       \State $asn\gets asn+1$;
%     \EndFor
%     \State $cmp\gets cmp+1$;
%   \EndFor
%   \State \textbf{return} $(asn, cmp)$;
%   \end{algorithmic}
% \end{algorithm}

\section{Operacijas skaičiuojantis patobulintas Šelo algoritmas}
% \begin{algorithm}[H]
%   \caption{Operacijas skaičiuojantis patobulintas Šelo algoritmas}
%   \label{alg:iss_reported}
%   \begin{algorithmic}[1]
%   \State $cmp\gets 0$; $asn\gets 0$;
%   \ForEach {$gap$ \textbf{in} $H$}
%     \For {$i\gets gap+1$ \textbf{to} $N$}
%       \State $j\gets i$; $temp\gets S[i]$;
%       \State $cmp\gets cmp+1$; $asn\gets asn+2$;
%       \While {$j > gap$  \textbf{and} $S[j - gap] > S[j]$}
%         \State $S[j]\gets S[j - gap]$;
%         \State $j\gets j-gap$;
%         \State $asn\gets asn+2$; $cmp\gets cmp+2$;
%       \EndWhile
%       \If {$j < gap$}
%         \State $cmp\gets cmp+1$;
%       \Else
%         \State $cmp\gets cmp+2$;
%       \EndIf
%       \State $S[j]\gets temp$;
%       \State $asn\gets asn+1$;
%     \EndFor
%   \EndFor
%   \State \textbf{return} $(asn, cmp)$;
%   \end{algorithmic}
% \end{algorithm}

\end{document}
