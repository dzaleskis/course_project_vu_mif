\documentclass{VUMIFInfKursinis}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{color}
\usepackage{graphicx}
\usepackage{hyperref}  % Nuorodų aktyvavimas
\usepackage{url}

\algnewcommand\algorithmicforeach{\textbf{foreach}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

% Titulinio aprašas
\university{Vilniaus universitetas}
\faculty{Matematikos ir informatikos fakultetas}
\institute{Informatikos institutas}  % Užkomentavus šią eilutę - institutas neįtraukiamas į titulinį
\department{Informatikos katedra}
\papertype{Kursinis darbas}
\title{Rikiavimo tobulinimas genetiniais algoritmais}
\titleineng{Improving sorting with genetic algorithms}
\status{3 kurso 2 grupės studentas}
\author{Deividas Zaleskis}
\supervisor{Irmantas Radavičius}
\date{Vilnius \\ \the\year}

% Nustatymai
\bibliography{bibliografija} 

\begin{document}
\maketitle

\tableofcontents

\sectionnonum{Įvadas}

Viena pagrindinių informatikos sąvokų yra algoritmas.
Formaliai algoritmą galima apibūdinti kaip
baigtinę seką instrukcijų, nurodančių kaip rasti nagrinėjamo uždavinio sprendinį.
Algoritmo koncepcija egzistuoja nuo senovės laikų \cite{knuth1972ancient}, tačiau atsiradus kompiuteriams,
tapo įmanoma algoritmų vykdymą automatizuoti, paverčiant juos mašininiu kodu suprantamu kompiuteriams \cite{wilkes1951preparation}.
Taip informatikos mokslas nuo teorinių šaknų \cite{turing1937computable} įgavo ir taikomąją pusę.
Beveik visus algoritmus galima suskirstyti į dvi klases: kombinatorinius algoritmus ir skaitinius algoritmus.
Skaitiniai algoritmai sprendžia tolydžius uždavinius: optimizuoti realaus argumento funkciją, išspręsti tiesinių lygčių sistemą su realiais koeficientais, etc.
Kombinatoriniai algoritmai sprendžia diskrečius uždavinius ir operuoja diskrečiais objektais: skaičiais, sąrašais, grafais, etc.
Apibendrinant, sunku įsivaizduoti informatikos mokslą be algoritmo sąvokos.

Vienas žinomiausių diskretaus uždavinio pavyzdžių yra duomenų rikiavimas.
Matematiškai jis formuluojamas taip:
duotai baigtinei palyginamų elementų sekai $S = (s_1, s_2, ..., s_n)$ pateikti tokį
kėlinį, kad pradinės sekos elementai būtų išdėstyti didėjančia (mažėjančia) tvarka \cite{Radavičius_Baranauskas_2013}.
Rikiavimo uždavinys yra aktualus nuo pat kompiuterių atsiradimo ir buvo laikomas vienu 
pagrindinių diskrečių uždavinių, kuriuos turėtų gebėti spręsti kompiuteris \cite{10.1145/356580.356581}.
Rikiavimo uždavinio sprendimas dažnai padeda pagrindą efektyviam kito uždavinio sprendimui,
pavyzdžiui, atliekant paiešką sąraše, galima taikyti dvejetainės paieškos algoritmą tik tada,
kai sąrašas yra išrikiuotas.
Taigi rikiavimas yra vienas pamatinių informatikos uždavinių.

Rikiavimo algoritmų yra įvairių:
paremtų palyginimu (elementų tvarką nustato naudojant palyginimo operatorius),
stabilių (nekeičia lygių elementų tvarkos),
nenaudojančių papildomos atminties (atminties sudėtingumas yra $O(1)$), etc.
Asimptotiškai optimalūs palyginimu paremti algoritmai blogiausiu atveju turi $O(n\,log\,n)$ laiko sudėtingumą,
o ne palyginimu paremti algoritmai gali veikti dar greičiau, tačiau nėra tokie universalūs, kadangi rikiuojama remiantis duomenų specifika.
Tiesa, rikiuojant remtis vien algoritmo asimptotika nepakanka:
rikiavimas įterpimu (angl. insertion sort) blogiausiu atveju turi $O(n^2)$ laiko sudėtingumą \cite{bender2006insertion},
tačiau mažesnius elementų kiekius rikiuoja daug greičiau, nei asimptotiškai optimalūs algoritmai,
pavyzdžiui, rikiavimas krūva (angl. heapsort) \cite{10.1145/512274.512284}.
Todėl pastaruoju metu plačiai naudojami hibridiniai rikiavimo algoritmai, kurie sujungia keletą rikiavimo
algoritmų į vieną ir panaudoja jų geriausias savybes.
Nepaisant įvairovės ir naujų algoritmų gausos, klasikiniai rikiavimo algoritmai išlieka aktualūs.

Šelo rikiavimo algoritmas (angl. Shellsort, toliau - Šelo algoritmas) \cite{10.1145/368370.368387} yra paremtas palyginimu, nenaudojantis papildomos atminties ir nestabilus.
Šelo algoritmą galima laikyti rikiavimo įterpimu modifikacija,
kuri lygina ne gretimus, o toliau vienas nuo kito esančius elementus, taip paspartindama jų perkėlimą į galutinę poziciją.
Pagrindinė algoritmo idėja - išskaidyti rikiuojamą seką S į posekius $S_1, S_2, ..., S_n$,
kur kiekvienas posekis $S_i = (s_i, s_{i+h}, s_{i+2h}, ...)$ yra sekos S elementai, kurių pozicija skiriasi $h$.
Išrikiavus visus sekos $S$ posekius $S_i$ su tarpu $h$, seka tampa $h$-išrikiuota.
Remiantis tuo, jog sekai S esant $h$-išrikiuota ir ją $k$-išrikiavus, ji lieka $h$-išrikiuota \cite{GALE1972103},
galima kiekvieną algoritmo iteraciją mažinti tarpą, taip vis didinant sekos $S$ išrikiuotumą.
Pritaikant šias idėjas ir rikiavimui naudojant mažėjančią tarpų seką su paskutiniu nariu $1$,
kuris garantuoja rikiavimą įterpimu paskutinėje iteracijoje,
galima užtikrinti, jog algoritmo darbo pabaigoje seka S bus pilnai išrikiuota.
Įvertinant Šelo algoritmo idėjas, nesunku pastebėti tarpų sekų įtaką jo veikimui.

Šelo algoritmo efektyvumas tiesiogiai priklauso nuo pasirinktos tarpų sekos.
Weiss atlikto tyrimo \cite{weiss1991short} rezultatai rodo, jog su Sedgewick pasiūlyta seka
šis algoritmas veikia beveik dvigubai greičiau nei Šelo pradinis variantas, kai $n = 1000000$.
Yra įrodyta, kad Šelo algoritmo laiko sudėtingumo blogiausiu atveju apatinė riba yra
$\Omega(\frac{n\,log^2\,n}{log\,log\,n^2})$ \cite{267769}, taigi jis nėra asimptotiškai optimalus.
Tiesa, kol kas nėra rasta seka, su kuria Šelo algoritmas pasiektų šią apatinę ribą.
Kiek žinoma autoriui, asimptotiškai geriausia tarpų seka yra rasta Pratt, kuri yra formos
$2^p3^p$ ir turi $\Theta(n\,log^2\,n)$ laiko sudėtingumą blogiausiu atveju \cite{pratt1972shellsort},
tačiau praktikoje ji veikia lėčiau už Ciura \cite{ciura2001best} ar Tokuda \cite{10.5555/645569.659879} pasiūlytas sekas.
Daugelio praktikoje efektyvių sekų asimptotinis sudėtingumas laiko atžvilgiu lieka atvira problema,
nes jos yra rastos eksperimentiškai.
Todėl ir dabar yra tikslinga ieškoti naujų ir efektyvesnių Šelo algoritmo tarpų sekų.

Vienas iš metodų, kuriuos galima taikyti efektyvių tarpų sekų radimui, yra genetinis algoritmas.
Genetinis algoritmas (GA) yra metodas rasti euristikas, paremtas biologijos žiniomis apie natūralios atrankos procesą.
Kartu su genetiniu programavimu, evoliuciniais algoritmais ir kitais metodais, % citations needed
genetiniai algoritmai sudaro evoliucinių skaičiavimų šeimą.
Visi šios šeimos atstovai yra paremti pradinės populiacijos generavimu ir iteraciniu populiacijos atnaujinimu naudojant biologijos įkvėptas strategijas.
J.H. Holland, GA pradininkas, savo knygoje \cite{holland1992adaptation}
apibrėžė genetinio algoritmo sąvoką ir su ja glaudžiai susijusias
chromosomų (potencialių uždavinio sprendinių, išreikštų genų rinkiniu), bei
rekombinacijos (tėvinių chromosomų genų perdavimo palikuonims),
atrankos (tinkamiausių chromosomų atrinkimo) ir mutacijos (savaiminio chromosomos genų kitimo) operatorių koncepcijas.
Genetinių algoritmų veikimo strategija pagrįsta pradinės chromosomų populiacijos evoliucija, kiekvienos naujos chromosomų kartos
gavimui naudojant rekombinacijos, atrankos ir mutacijos operatorius.
Nesunku pastebėti, jog genetiniai algoritmai gali palengvinti tam tikrų rūšių uždavinių sprendimą.

Genetiniai algoritmai taikomi sprendžiant įvairius paieškos ir optimizavimo uždavinius, kuomet nesunku nustatyti, ar sprendinys tinkamas,
tačiau tinkamo sprendinio radimas reikalauja daug resursų ar net pilno perrinkimo.
Tokiu atveju apytikslio sprendinio radimas (euristika) gali būti daug patrauklesnis sprendimo būdas,
kadangi tikslaus sprendinio radimas dažnai yra NP-sunkus uždavinys.
Todėl GA yra pritaikomi sudarant grafikus ir tvarkaraščius,
sprendžiant globalaus optimizavimo uždavinius
ir net projektuojant NASA mikrosatelitų antenas \cite{hornby2006automated}.
Nesunku pastebėti, jog efektyvių Šelo algoritmo tarpų sekų radimas yra sunkus uždavinys atliekamų skaičiavimų prasme,
tikėtinai reikalaujantis pilno potencialių sprendinių perrinkimo,
tad šio uždavinio sprendimui taikyti GA yra prasminga.
Kiek žinoma autoriui, kol kas yra buvę du bandymai taikyti genetinius algoritmus efektyvių Šelo algoritmo tarpų sekų radimui \cite{simpson1999faster, roos2002genetic}.
Abiejuose darbuose teigiama, jog genetiniais algoritmais gautos tarpų sekos veikia greičiau už Sedgewick seką, kuri literatūroje laikoma viena efektyviausių.

\pagebreak

Darbo \textbf{tikslas}:
pritaikyti genetinius algoritmus Šelo algoritmo tarpų sekoms generuoti.

Darbo uždaviniai:
\begin{itemize}
  \item Atlikti Šelo rikiavimo algoritmo literatūros analizę.
  \item Atlikti genetinių algoritmų literatūros analizę.
  \item Nustatyti kriterijus tarpų sekų efektyvumui įvertinti.
  \item Naudojant genetinius algoritmus sugeneruoti tarpų sekas.
  \item Paruošti aplinką eksperimentų vykdymui.
  \item Atliekant eksperimentus įvertinti sugeneruotų ir pateiktų literatūroje tarpų sekų efektyvumą.
\end{itemize}

Šis darbas sudarytas iš 5 skyrių.
Pirmame skyriuje atliekama Šelo rikiavimo algoritmo literatūros analizė.
Antrame skyriuje atliekama genetinių algoritmų literatūros analizė.
Trečiame skyriuje nustatomi kriterijai tarpų sekų efektyvumui įvertinti.
Ketvirtame skyriuje naudojant genetinius algoritmus generuojamos tarpų sekos.
Penktame skyriuje paruošiama eksperimentų vykdymo aplinka.
Šeštame skyriuje atliekant eksperimentus įvertinamas sugeneruotų ir pateiktų literatūroje tarpų sekų efektyvumas.

\section{Šelo rikiavimo algoritmas}

Šis skyrius sudarytas iš 2 poskyrių.
Pirmame poskyryje nagrinėjama Šelo algoritmo veikimo sparta.
Antrame poskyryje analizuojamos Šelo algoritmo versijos.

\subsection{Šelo rikiavimo algoritmo veikimo sparta}

Šiame poskyryje nagrinėjamas Šelo algoritmo veikimo greitis priklausomai nuo duomenų dydžio ir duomenų specifikos.

\subsubsection{Veikimo greitis priklausomai nuo duomenų dydžio}

Renkantis kokį algoritmą naudoti, labai svarbu įvertinti tikėtiną duomenų dydį.
Šelo rikiavimo algoritmas veikia greičiausiai, kai duomenų dydis yra ganėtinai mažas \cite{ciura2001best}.
Kaip teigiama \cite{simpson1999faster}, ši savybė galioja, kai $N \leq 106$.
Tokiu atveju, Šelo algoritmas lenkia net ir vienu greičiausių laikomą greitojo rikiavimo algoritmą.
Todėl Šelo rikiavimo algoritmas dažnai naudojamas hibridiniuose rikiavimo algoritmuose, kai pasiekus tam tikrą rekursijos lygį
rikiuojamų duomenų dalis tampa pakankamai maža ir tolimesnė rekursija asimptotiškai optimaliu algoritmu nebeturi prasmės,
kadangi jos tęsimas reikalautų per daug mašinos resursų.
Tokių šio algoritmo naudojimo pavyzdžių galima rasti Go programavimo kalbos standartinėje bibliotekoje \cite{golangsort} bei
bzip2 failų glaudinimo programoje \cite{bzip2sort}.
Tiesa, net ir rikiuojant didesnius duomenų dydžius, Šelo algoritmas nėra labai lėtas \cite{ciura2001best}.
Todėl jis yra vertingas įrankis įgyvendinant operacinės sistemos branduolį ar programuojant įterptinėms sistemoms, kadangi dėl ribotų atminties išteklių
asimptotiškai optimalūs algoritmai, kurie dažniausia yra rekursyvūs ir naudoja daugiau atminties, tokiais atvejais netinka.
Taigi, nors Šelo rikiavimo algoritmas nėra labai greitas, kai uždavinys didelis,
yra scenarijų, kuriais jį rinktis tikrai verta.

\subsubsection{Veikimo greitis priklausomai nuo duomenų specifikos}

Viena palankiausių Šelo algoritmo savybių yra jo adaptyvumas.
Adaptyvumas rikiavimo algoritmų kontekste reiškia, jog algoritmas atlieka mažiau operacijų, jei duomenys dalinai išrikiuoti.
Adaptyvumą Šelo algoritmas paveldi iš rikiavimo įterpimu, nes yra jo optimizacija.
Moksliniuose tyrimuose ši savybė retai turi įtakos, kadangi dažniausia siekiama ištirti algoritmo veikimą, kai duomenys
nėra tvarkingai išdėstyti ir tipiškai renkamasi atsitiktinai generuoti pradinius duomenis šiam tikslui pasiekti.
Savaime aišku, jog praktikoje retai pavyks sutikti visiškai atsitiktinai išsidėsčiusius duomenis, neturinčius nei vieno išrikiuoto posekio ilgesnio nei 1.
Kaip parodo \cite{10.1145/359024.359026}, Šelo algoritmas veikia net keletą kartų greičiau, kai duomenys yra pilnai
išrikiuoti ir veikimo sparta nusileidžia tik rikiavimui įterpimu su visais duomenų dydžiais.
Kai duomenų dydis nedidelis (iki 200 elementų) ir 20\% elementų nėra teisingose pozicijose, Šelo algoritmas veikimo sparta nusileidžia tik greitojo rikiavimo algoritmui.
Palankūs rezultatai pateikiami ir \cite{7280062} - su dalinai išrikiuotais duomenimis Šelo algoritmas veikia apytiksliai 1.5 karto greičiau, o su išrikiuotais
duomenimis pasiekiamas apie 3.8 karto mažesnis veikimo greitis.
Taigi rikiuojant bent dalinai išrikiuotus duomenis Šelo algoritmas veikia žymiai greičiau.

\subsection{Šelo rikiavimo algoritmo versijos}

Šiame poskyryje analizuojami du Šelo algoritmo variantai: vadovėlinis Šelo algoritmas ir patobulintas Šelo algoritmas. 

\subsubsection{Vadovėlinis Šelo rikiavimo algoritmas}


\begin{algorithm}[H]
  \caption{Vadovėlinis Šelo rikiavimo algoritmas}\label{alg:tss}
  \begin{algorithmic}[1]
  \ForEach {$gap$ \textbf{in} $H$}
    \For {$i\gets gap+1$ \textbf{to} $N$}
      \State $j\gets i$
      \State $temp\gets S[i]$\label{alg:tss:assign1}
      \While {$j > gap$ \textbf{and} $S[j - gap] > S[j]$}\label{alg:tss:while:start}
        \State $S[j]\gets S[j - gap]$
        \State $j\gets j-gap$
      \EndWhile\label{alg:tss:while:end}
      \State $S[j]\gets temp$\label{alg:tss:assign2}
    \EndFor
  \EndFor
  \end{algorithmic}
\end{algorithm}

Kaip ir daugelis algoritmų, Šelo rikiavimo algoritmas turi keletą galimų implementacijų.
Žinomiausia iš jų, be abejo, yra vadovėlinė šio algoritmo versija (toliau - VŠA),
kurią D. L. Shell paskelbė dar 1959 metais \cite{shell1959high}.
Jos pseudokodas pateikiamas \ref{alg:tss} algoritme.

Įdėmiau įsižiūrėjus, nesunku pastebėti Šelo algoritmo panašumą į paprastą rikiavimą įterpimu - pašalinus išorinį ciklą, iteruojantį tarpų sekos narius bei pakeitus
kintamąjį $gap$ į $1$, gaunamas būtent šio algoritmo kodas.
Paties rikiavimo įterpimu idėja yra gana paprasta: pradžioje rikiuojama seka yra suskaidoma į du posekius,
kur kairysis (susidedantis iš kairiausio sekos elemento) yra išrikiuotas, o dešinysis (susidedantis iš visų likusių sekos elementų) - ne.
Tada kiekvieną iteraciją išrikiuotas posekis yra plečiamas, imant kairiausią neišrikiuoto posekio elementą ir įterpiant jį į išrikiuotą posekį.
Naujų elementų įterpimas į išrikiuotą posekį vyksta iteratyviai sukeičiant įterpiamą elementą su elementu, esančiu jam iš kairės, jei šis yra didesnis už įterpiamą elementą.
Algoritmas baigia darbą, kai neišrikiuoto posekio ilgis yra 0.

Verta pastebėti, jog Šelo algoritmas tėra rikiavimo įterpimu generalizacija, kur įterpimas gali vykti atstumu, didesniu nei 1.
Būtent didesnis įterpimo atstumas ir suteikia Šelo algoritmui pranašumą, kadangi labiausiai nuo galutinės pozicijos nutolę elementai gali greičiau patekti į reikiamą poziciją.
Šelo algoritmo idėjos turi tvirtą matematinį pagrindą: rikiavimas įterpimu turi $O(n^2)$ laiko sudėtingumą blogiausiu atveju (pavyzdžiui, kai rikiuojama seka yra išrikiuota atgaline tvarka),
tačiau kai didžiausias atstumas tarp dviejų neišrikiuotų elementų yra $k$, rikiavimo įterpimu laiko sudėtingumas yra $O(kn)$.
Taigi seką $h$-išrikiavus, paskutinė iteracija turės $O(hn)$ laiko sudėtingumą.
Iteracijos su dideliais tarpais taip pat yra gana greitos, kadangi dirbama su daug mažesniais elementų kiekias,
o šiuo atveju rikiavimas įterpimu yra vienas greičiausių.

\subsubsection{Patobulintas Šelo rikiavimo algoritmas}

Verta pastebėti, jog vadovėlinė Šelo algoritmo implementacija nėra pilnai efektyvi \cite{Radavičius_Baranauskas_2013}.
Vykdant vidinį vadovėlinio Šelo algoritmo ciklą (\ref{alg:tss} algoritmo \ref{alg:tss:while:start}-\ref{alg:tss:while:end} eilutės),
\ref{alg:tss:while:start} eilutėje yra tikrinama, ar $S[j]$ jau yra tinkamoje pozicijoje.
Jei $S[j]$ jau yra tinkamoje pozicijoje, vidinis ciklas nėra vykdomas ir jokių elementų pozicijos nėra keičiamos.
Tačiau \ref{alg:tss:assign1} ir \ref{alg:tss:assign2} eilutėse vis tiek yra vykdomi du priskyrimai,
kurie šiuo atveju nueina veltui (o taip nutinka pakankamai dažnai).
Siekiant tai ištaisyti, \cite{Radavičius_Baranauskas_2013} pateikė patobulintą Šelo algoritmo versiją (toliau - PŠA),
kurią galima rasti \ref{alg:iss} algoritme.

PŠA prieš vykdydamas bet kokius kitus žingsnius patikrina, ar elementas $S[j]$ jau yra tinkamoje pozicijoje
(žr. \ref{alg:iss} algoritmo \ref{alg:iss:check} eil.), kas leidžia sumažinti atliekamų priskyrimų skaičių,
kai su $S[j]$ pagrindinės rikiavimo logikos (\ref{alg:iss} algoritmo \ref{alg:iss:inner:start}-\ref{alg:iss:inner:end} eil.) nėra reikalo vykdyti.
Taip pat, kadangi iš pat pradžių yra užtikrinama, jog galima atlikti nors vieną sukeitimą,
vadovėlinio Šelo algoritmo $while$ ciklą (\ref{alg:tss} algoritmo \ref{alg:tss:while:start}-\ref{alg:tss:while:end} eil.)
galima pakeisti $repeat\,...\,until$ tipo ciklu, kas ir yra atliekama \ref{alg:iss} algoritmo \ref{alg:iss:loop:start}-\ref{alg:iss:loop:end} eilutėse.

Reikia pastebėti, jog patobulintas Šelo algoritmas nuo vadovėlinės versijos atliekamų operacijų prasme skiriasi tik
atliekamais priskyrimais.
Tačiau šios optimizacijos svarba pasirodo pakankamai didelė -
autorių teigimu \cite{Radavičius_Baranauskas_2013}, PŠA vidutiniškai atlieka 40-80\% mažiau priskyrimų ir veikia 20\% greičiau, nei VŠA.
Tiesa, PŠA nėra plačiai naudojamas, o jo veikimas vidutiniu atveju originaliame darbe ištirtas tik rėžyje $500 \leq N \leq 2000$.

\begin{algorithm}[H]
  \caption{Patobulintas Šelo rikiavimo algoritmas}\label{alg:iss}
  \begin{algorithmic}[1]
  \ForEach {$gap$ \textbf{in} $H$}
    \For {$i\gets gap+1$ \textbf{to} $N$}
      \If {$S[i-gap] > S[i]$}\label{alg:iss:check}
        \State $j\gets i$\label{alg:iss:inner:start}
        \State $temp\gets S[i]$
        \Repeat\label{alg:iss:loop:start}
          \State $S[j]\gets S[j - gap]$
          \State $j\gets j-gap$
        \Until {$j \le gap$ or $S[j - gap] \le S[j]$}\label{alg:iss:loop:end}
        \State $S[j]\gets temp$\label{alg:iss:inner:end}
      \EndIf
    \EndFor
  \EndFor
  \end{algorithmic}
\end{algorithm}

\section{Genetiniai algoritmai}

Paprasčiausias genetinis algoritmas susideda iš chromosomų populiacijos bei atrankos, mutacijos ir rekombinacijos operatorių \cite{simpson1999faster}.
Šiame skyriuje bus nagrinėjamos šių terminų reikšmės ir genetinių algoritmų veikimo principai.

\subsection{Chromosomų populiacija}

Chromosoma GA kontekste vadiname potencialų uždavinio sprendinį.
Projektuojant genetinį algoritmą tam tikro uždavinio sprendimui, svarbu tinkamai pasirinkti,
kaip kompiuteriu modeliuoti galimus sprendinius (chromosomas).
Chromosomos kompiuterio atmintyje standartiškai išreiškiamos bitų eilutėmis \cite{whitley1994genetic},
kadangi tai palengvina tiek mutaciją (pakanka apversti kurio nors atsitiktinio bito reikšmę),
tiek rekombinaciją (pakanka perkopijuoti pasirinktus tėvinių chromosomų bitus į vaikinę chromosomą).
Tiesa, tai nėra vienintelis įmanomas būdas, ir kai kurių uždavinių sprendiniai modeliuojami pvz. grafu ar simbolių eilute.

Sprendinio kokybę įvardijame kaip jo tinkamumą, kuris apibrėžiamas tinkamumo funkcijos reikšme, pateikus sprendinį kaip parametrą.
Nesunku pastebėti, jog tinkamumo funkcija tėra tikslo funkcijos specializacija, kuri naudojama chromosomų vertinimui.
Tinkamumo funkcija yra viena svarbiausių genetinio algoritmo dalių,
kadangi kai ji netinkamai parinkta, algoritmas nekonverguos į tinkamą sprendinį arba užtruks labai ilgai.

Chromosomų rinkinys, literatūroje dažnai vadinamas populiacija, atspindi uždavinio sprendinių aibę, kuri kinta kiekvieną genetinio algoritmo iteraciją.
Populiaciją dažnu atveju sudaro šimtai ar net tūkstančiai individų.
Tiesa, populiacijos dydį būtina nustatyti priklausomai nuo sprendžiamo uždavinio, kadangi per didelės populiacijos pasirinkimas
chromosomų kokybės gali nepadidinti ir privesti prie resursų švaistymo.
Jei GA suprojektuotas tinkamai, dažnu atveju vidutinis populiacijos tinkamumas gerės kiekvieną iteraciją \cite{simpson1999faster}.

\subsection{Genetiniai operatoriai}

Esminė GA dalis yra populiacijos genetinės įvairovės užtikrinimas, geriausių individų atranka ir kryžminimasis.
Šiems procesams nesunku rasti atitikmenis nagrinėjant gamtoje vykstančius evoliucinius reiškinius.
Siekiant užtikrinti šių procesų išpildymą, genetinis algoritmas vykdymo metu
iteratyviai atnaujina esamą populiaciją ir kuria naujas kartas
taikydamas biologijos žiniomis paremtus atrankos, rekombinacijos ir mutacijos operatorius.

Atrankos operatorius grąžina tinkamiausius populiacijos individus, kuriems yra leidžiama susilaukti palikuonių taikant rekombinacijos operatorių.
Dažniausiai atranka vykdoma atsižvelgiant į populiacijos individų tinkamumą, atrenkant ir pateikiant rekombinacijai tuos, kurių tinkamumas yra geriausias.
Verta pastebėti, jog įprastai rekombinacijai yra pasirenkama tam tikra fiksuota einamosios populiacijos dalis
ir daugelyje GA implementacijų šis dydis yra nurodomas kaip veikimo parametras.
Įprastai populiacijos dalis, kuri nebuvo atrinkta rekombinacijai, būna mažesnė.
Dažniausiai ir jai priklausančios chromosomos yra perkeliamos į kitą GA iteraciją, siekiant užtikrinti naujos populiacijos genetinę įvairovę.
Tinkamas rekombinacijai atrenkamos populiacijos dalies pasirinkimas yra svarbus, kadangi
kai šis parametras per didelis, populiacija pradeda konverguoti per anksti ir nėra atliekama pakankamai plati galimų sprendinių paieška.

Rekombinacijos operatorius įprastai veikia iš dviejų tėvinių chromosomų sukurdamas naują vaikinę chromosomą, kas dažniausiai pasiekiama
tam tikru būdu perkopijuojant tėvų genų atkarpas į vaikinę chromosomą.
Tiesa, kai kurie tyrimai \cite{ting2005mean,eiben1994genetic} rodo, jog rekombinacijai naudojant daugiau nei du tėvus,
gautų vaikinių chromosomų kokybė yra geresnė.
Šiame darbe paprastumo dėlėi bus laikoma, jog rekombinacija vyksta naudojant tik du tėvus.
Rekombinacijos strategijų yra įvairių, tačiau ne kiekvienam uždaviniui visos jos tinka, kadangi
kai kuriais atvejais netinkamai parinkta rekombinacijos strategija pagamina neatitinkančią uždavinio apribojimų vaikinę chromosomą.
Pavyzdžiui, jei modeliuojama chromosoma yra sąrašas, turintis susidėti iš tam tikrų elementų, neįmanoma garantuoti, jog atsitiktinai
perkopijavus tėvinių chromosomų genus į vaikinę chromosomą šis apribojimas bus išlaikytas.
Šiai problemai spręsti yra pasitelkiamos specializuotos rekombinacijos strategijos \cite{larranaga1996learning} arba įvedama chromosomų normalizacija.

Galiausiai tam tikrai populiacijos daliai yra pritaikomas mutacijos operatorius.
Jo veikimo principas yra gana paprastas: pasirinktos chromosomos vienas ar keli genai yra modifikuojami,
nežymiai pakeičiant jų reikšmes ar sukeičiant kelių genų reikšmes vietomis.
Mutacijos operatorius praplečia vykdomos paieškos erdvę, o tai labai svarbu, kadangi kitaip algoritmas gali konverguoti
į lokaliojo minimumo taškus, taip ir nepasiekdamas globaliojo minimumo.
Atsižvelgiant į tai, yra laikoma, jog mutacijos operatorius yra kertinė genetinio algoritmo dalis,
kuri palaiko genetinę individų įvairovę ir padeda rasti tinkamiausius sprendinius.
Įprastai mutacija kiekvienai chromosomai taikoma su tam tikra tikimybe, kuri nurodoma kaip vienas iš GA veikimo parametrų.
Tinkamas chromosomos mutacijos tikimybės parinkimas yra vienas iš svarbiausių sprendimų projektuojant GA,
kadangi nuo mutacijos tikimybės dažnu atveju priklauso gaunamų sprendinių kokybė.
Jei mutacijos tikimybė yra per didelė, GA išsigimsta į primityvią atsitiktinę paiešką \cite{hassanat2019choosing} ir rizikuojama prarasti geriausius sprendinius.
Jei mutacijos tikimybė per maža, tai gali vesti prie genetinio dreifo \cite{masel2011genetic},
kas reiškia, jog populiacijos genetinė įvairovė palaipsniui mažės.

\subsection{Genetinių algoritmų veikimo principai}

Apjungiant visas aukščiau aptartas genetinio algoritmo dalis, galima suformuluoti paprasto genetinio algoritmo pseudokodą.
Jis pateikiamas \ref{simple_GA} algoritme.
Kintamieji $N$ (populiacijos dydis), $mutation\_rate$ (mutacijos tikimybė) bei $recombination\_frac$ (rekombinacijai pateikiamų chromosomų dalis)
tipiškai būtų nustatomi vartotojo ir perduodami kaip parametrai, tačiau paprastumo dėlei
pakanka laikyti, jog jie nustatomi paties GA.
Algoritmui pradedant darbą yra inicializuojama pradinė chromosomų populiacija (žr. \ref{simple_GA:init_pop} eil.).
Vykdant pagrindinį GA ciklą, pirmiausia
yra įvertinamas einamosios populiacijos tinkamumas (žr. \ref{simple_GA:eval_pop} eil.).
Tada iš tinkamiausių populiacijos individų yra atsitiktinai atrenkamos dvi tėvinės chromosomos,
kurioms taikant rekombinacijos operatorių yra kuriami nauji individai (žr. \ref{simple_GA:recomb1}-\ref{simple_GA:recomb2} eil.).
Naujam individui su tam tikra tikimybe taip pat yra taikomas mutacijos operatorius (žr. \ref{simple_GA:mut1}-\ref{simple_GA:mut2} eil.).
Naujų individų generavimas yra kartojamas, kol naujos populiacijos dydis siekia $N$ (žr. \ref{simple_GA:generate_end} eil.).
Galiausiai einamajai populiacijai yra priskiriama naujai sugeneruota populiacija (žr. \ref{simple_GA:assign} eil.),
kas užtikrina, jog kitą ciklo iteraciją bus dirbama su naujais individais.
Prieš pradedant kitą ciklo iteraciją (žr. \ref{simple_GA:loop_end} eil.), GA patikrina, ar kažkuri iš sustojimo sąlygų yra patenkinta, ir jei taip - baigia darbą.
Praktikoje dažnai siekiama, jog GA sustotų, kai yra pasiektas maksimalus
kartų skaičius ar vidutinio tinkamumo pokytis tarp paskutinių dviejų populiacijos kartų yra pakankamai mažas.
Tokie sustojimo kriterijai nurodomi, jog GA nenaudotų per daug resursų, ypač jei galima nuspėti, jog tolesnis veikimas neduos geresnių rezultatų.
Žinoma, pateiktas GA yra pakankamai paprastas ir praleidžia daugelį detalių, tačiau autorius mano, jog jis tinkamai iliustruoja pagrindinius genetinių algoritmų veikimo principus.

\begin{algorithm}[H]
  \caption{Paprastas GA}\label{simple_GA}
  \begin{algorithmic}[1]
    \State Let $current\_population$ be a random population of chromosomes.\label{simple_GA:init_pop}
    \Repeat\label{simple_GA:loop_start}
      \State Apply the fitness function to each chromosome in $current\_population$.\label{simple_GA:eval_pop}
      \State Sort the chromosomes in $current\_population$ based on their fitness in descending order.
      \State Let $new\_population$ be an empty set.
      \Repeat\label{simple_GA:generate_start}
        \State Let $(parent1, parent2)$ be a pair of parent chromosomes selected randomly from the first $[N * recombination\_frac]$ elements of $current\_population$.\label{simple_GA:recomb1}
        \State Let $child\_chromosome$ be the result of applying the recombination operator to $parent1$ and $parent2$.\label{simple_GA:recomb2}
        \If {$rand01() \leq mutation\_rate$}\label{simple_GA:mut1}
          \State Apply the mutation operator to $child\_chromosome$
        \EndIf\label{simple_GA:mut2}
        \State Add $child\_chromosome$ to $new\_population$
      \Until N offspring have been created.\label{simple_GA:generate_end}
      \State Assign $new\_population$ to $current\_population$.\label{simple_GA:assign}
    \Until Some termination criterion is satisfied.\label{simple_GA:loop_end}
  \end{algorithmic}
\end{algorithm}

\section{Tarpų sekų efektyvumo kriterijų nustatymas}

Šelo algoritmo tarpų sekų efektyvumo įvertinimas nėra trivialus.
Rikiavimo algoritmai dažniausiai yra vertinami pagal atliekamų priskyrimų skaičių, kadangi
daugelyje algoritmų priskyrimų skaičius uždaviniui augant greitai artėja prie palyginimų skaičiaus ir
tokiu metodu gautas įvertis būna pakankamai tikslus.
Tačiau Šelo algoritmo atveju, atliekamų palyginimų ir priskyrimų skaičiaus santykis augant $N$ nebūtinai artėja prie 1 \cite{Radavičius_Baranauskas_2013}.
Taigi, vien priskyrimų skaičius nėra pakankamai tikslus kriterijus tarpų sekų efektyvumui įvertinti,
kadangi juo remiantis gautas įvertis pilnai neatspindi praktinio sekos efektyvumo.
Kaip parodo \cite{ciura2001best}, šiame algoritme dominuojanti operacija yra palyginimas ir efektyvios sekos
turėtų jų atlikti kuo įmanoma mažiau.
Apibendrinant, atliekamų palyginimų skaičius yra tinkamesnis kriterijus Šelo algoritmo tarpų sekų efektyvumui įvertinti.

Matuojant rikiavimo algoritmo efektyvumą tik naudojant sveikaskaitinius pradinius duomenis, gauti rezultatai gali būti netikslūs,
kadangi palyginimo ir priskyrimo operacijų sparta priklauso nuo rikiuojamų duomenų tipo.
Rikiuojant simbolių eilutes, priskyrimas atliekamas naudojant rodykles, kas yra $O(1)$ operacija,
tačiau palyginimas yra $O(n)$ blogiausiu atveju.
Ir atvirkščiai, rikiuojant įrašus, priskyrimas reikalauja perkopijuoti visą įrašą, tad šios operacijos sudėtingumas yra $O(n)$,
o palyginimas gali būti atliekamas naudojant tam tikrą raktą, taigi tik $O(1)$.
Todėl apsiriboti vien palyginimų ar priskyrimų skaičiumi nepakanka, kadangi tiksliausia praktinio algoritmo
veikimo laiko aproksimacija (tai, kam ir skaičiuojamos operacijos), bus gauta tik įvertinant abu šiuos rodiklius.

Algoritmo veikimo laikas, nors ir priklausomas nuo platformos, kurioje vykdomas tyrimas, detalių,
taip pat gali duoti tinkamų įžvalgų įvertinant praktinį efektyvumą.
Kadangi algoritmo atliekamos operacijos skaičiuojamos tam, jog gauti
veikimo laiko aproksimaciją, tai realus veikimo laikas
yra konkretus įvertis, leidžiantis praktiškai įvertinti duotos sekos efektyvumą.
Taigi, įvertinant tarpų sekų efektyvumą bus remiamasi visomis atliekamomis operacijomis bei realiais veikimo laikais.

Autoriaus nuomone, atliktų palyginimų skaičius yra svarbiausias kriterijus tarpų sekų efektyvumui įvertinti ir
didžiausias svoris atliekant bendrą visų kriterijų vertinimą turėtų būti teikiamas būtent jam.
Vertinant kitus du kriterijus, didesnis svoris turėtų atitekti atliekamų palyginimų skaičiui,
kadangi veikimo laiko įvertis nėra universalus.
Verta pastebėti, jog atliktų priskyrimų skaičių reikia vertinti, atsižvelgiant į kontekstą, kadangi
seka, kuri atlieka daug priskyrimų, nebūtinai yra neefektyvi - daug svarbesnis yra atliekamų palyginimų ir priskyrimų santykis.
Tai galima paaiškinti paprastu pavyzdžiu: jei su tam tikra tarpų seka Šelo algoritmas atlieka santykinai mažai palyginimų ir daug priskyrimų, galima laikyti,
jog su ja algoritmas dirba pakankamai efektyviai, kadangi atlikti palyginimai nenueina veltui ir rikiuojamos sekos $S$ elementai greitai artėja link galutinės pozicijos.
Reikia atsižvelgti ir į tai, jog vadovėlinė Šelo algoritmo implementacija dažnai atlieka nereikalingus priskyrimus \cite{Radavičius_Baranauskas_2013},
tad atliekant sekų vertinimą, gali būti tikslinga įvertinti sekas naudojant ir VŠA, ir PŠA.
Savaime suprantama, jog į veikimo laiką verta žvelgti kritiškai, kadangi jis priklauso nuo algoritmo implementacijos,
eksperimentams naudojamos mašinos techninių parametrų, operacinės sistemos, pasirinktos programavimo kalbos ar net kompiliatoriaus versijos.
Todėl vertinant veikimo laiką, svarbiausia atsižvelgti į santykinius gautų rezultatų skirtumus naudojant skirtingas tarpų sekas.

\section{Tarpų sekų generavimas}

Šį skyrių sudaro 2 poskyriai.
Pirmame poskyryje naudojant genetinius algoritmus generuojamos trumpos tarpų sekos.
Antrame poskyryje naudojant genetinius algoritmus generuojamos vidutinio ilgio tarpų sekos.

\subsection{Trumpų tarpų sekų generavimas}
Pirmame etape buvo generuojamos tarpų sekos, kurios efektyvios kai $N=1000$.
Trumpų sekų generavimui buvo paruoštas vienkriterinis genetinis algoritmas.
GA implementacijai buvo pasirinkta OpenGA biblioteka \cite{mohammadi2017openga}
dėl suteikiamos laisvės pasirinkti, kaip įgyvendinti genetinius operatorius bei modernių kalbos konstruktų ir lygiagretaus vykdymo palaikymo.
Remiantis \cite{simpson1999faster}, trumpos sekos chromosoma buvo modeliuojama kaip
septynių sveikų skaičių masyvas.
Chromosomos buvo vertinamos jas naudojant 20 atsitiktinai
sugeneruotų sveikų skaičių masyvų, turinčių po 1000 elementų, rikiavimui vadovėline Šelo rikiavimo algoritmo versija ir skaičiuojant atliktas palyginimo operacijas.
Chromosomos tinkamumo funkcija buvo apibrėžta kaip atliktų palyginimų skaičiaus aritmetinis vidurkis.
Rekombinacijos operatorius buvo įgyvendintas tolygia strategija, kur abiejų tėvų genai turi vienodą tikimybę
būti perduoti vaikinei chromosomai.
GA sustojimo kriterijumi buvo pasirinkta laikyti tinkamiausio individo nepakitimą 25 iteracijas.
Mutacijos operatorius buvo įgyvendintas su $\frac{1}{5}$ tikimybe keičiant tam tikrą chromosomą,
pridedant prie atsitiktinai pasirinkto geno reikšmės skaičių $\left[(rand01()-rand01())*\frac{25}{\sqrt{karta}}\right]$ su apribojimu, jog pakeistas genas turi priklausyti intervalui $[1, 1000]$.
Siekiant išvengti netinkamų sprendinių, kiekviena seka po rekombinacijos ar mutacijos operatorių taikymo buvo išrikiuojama ir
užtikrinama, jog paskutinis sekos narys yra 1.

GA buvo vykdomas su atsitiktinai sugeneruota 10000 individų populiacija, kiekvieną iteraciją pritaikant rekombinacijos operatorių
$\frac{1}{2}$ populiacijos.
Tokiu būdu buvo sugeneruota ir atrinkta 10 sekų.
Po to iš visų sugeneruotų sekų buvo atrinkta tinkamiausia, sugeneruotas sekas naudojant 10000 atsitiktinai sugeneruotų masyvų, turinčių po 1000 elementų, rikiavimui
ir matuojant atliktų palyginimo operacijų aritmetinį vidurkį.
Atlikus matavimus, buvo pasirinkta seka $855, 264, 86, 35, 12, 5, 1$ (toliau - S1).

\subsection{Vidutinio ilgio tarpų sekų generavimas}
Antrame etape buvo generuojamos tarpų sekos, kurios efektyvios kai $N=100000$.
Vidutinio ilgio sekų generavimui buvo pasitelktas modifikuotas genetinis algoritmas, naudotas generuojant trumpas tarpų sekas.
Tarpų sekos chromosoma buvo modeliuojama kaip 12 sveikų skaičių masyvas.
Buvo atsisakyta chromosomų vertinimo naudojant 20 skirtingų masyvų, kadangi tai darė neigiamą įtaką genetinio algoritmo veikimo laikui.
Vietoje to, kiekvienos sekos vertinimui buvo naudojami 5 atsitiktinai sugeneruoti 100000 elementų masyvai.
GA buvo nurodyta sustoti, kai kartų skaičius pasieks 100.
Mutacijos operatorius buvo pakoreguotas ir su $\frac{1}{5}$ tikimybe keitė tam tikrą chromosomą,
pridedant prie atsitiktinai pasirinkto geno reikšmės skaičių $\left[(rand01()-rand01())*\frac{75}{\sqrt{karta}}\right]$.

GA buvo vykdomas su atsitiktinai sugeneruota 1000 individų populiacija,
paskutinius septynis kiekvienos chromosomos genus inicializuojant elementais $855, 264, 86, 35, 12, 5, 1$, t.y. sekos, gautos pirmame etape, nariais.
Siekiant išlaikyti tinkamiausius sprendinius, buvo pasitelktas elitizmas - didžiausią tinkamumą turinčios 75 chromosomos nekeistos
patekdavo į kitą algoritmo iteraciją.
Rekombinacijos operatorius buvo taikomas $\frac{1}{2}$ populiacijos kiekvieną algoritmo iteraciją.
Tokiu būdu buvo sugeneruota ir atrinkta 10 sekų.
Po to iš visų sugeneruotų sekų buvo atrinkta tinkamiausia, naudojant tokį pat metodą kaip ir praeitame etape, tik pakeitus rikiuojamų masyvų dydį į 100000.
Atlikus matavimus, buvo pasirinkta seka $45794, 17396, 7414, 3136, 1206, 561, 264, 86, 35, 12, 5, 1$ (toliau - S2).


\section{Eksperimentų vykdymo aplinkos paruošimas}

Siekant išmatuoti VŠA bei PŠA atliekamų operacijų skaičių,
buvo parengtos modifikuotos šių algoritmų versijos, kurios kaip rezultatą grąžina atliktus palyginimus bei priskyrimus.

Verta pastebėti, jog matuoti veikimo laiką naudojant operacijas skaičiuojančius algoritmus nėra tinkama,
kadangi pats operacijų skaičiavimas reikalauja papildomų žingsnių, o tai gali iškreipti gautus rezultatus.
Atsižvelgiant į tai, veikimo laiko matavimui naudoti nemodifikuoti VŠA ir PŠA algoritmai.
Veikimo laiko matavimai buvo atlikti matuojant sisteminio laiko reikšmę prieš algoritmo vykdymą bei po jo.
Šių įverčių skirtumo absoliuti vertė buvo laikoma algoritmo veikimo laiku.
Tiesa, toks matavimo būdas nėra idealus, kadangi sisteminis laikas ne visada sutampa su laiku, kurį programa buvo vykdoma (OS bet kada gali atimti procesorių)
ir geriausia būtų matuoti laiką, kurį programa naudojo procesorių. Deja, dėl techninių priežasčių to atlikti nebuvo įmanoma, tad buvo apsiribota sisteminio laiko matavimu.

Vykdant eksperimentus buvo pasirinkta naudoti sveikaskaitinius pradinius duomenis, kadangi jų generavimas yra pakankamai paprastas.
Tai buvo įgyvendinta naudojant MT19937 pseudoatsitiktinių skaičių generatorių, inicializuotą sisteminio laiko reikšme.
Generuojami duomenys buvo tolygiai paskirstyti nuo INT\_MIN iki INT\_MAX, kas leido žymiai sumažinti duomenų duplikacijos tikimybę.

Eksperimentų vykdymui buvo naudojamas kompiuteris su 2.70 GHz Intel(R) Core(TM) i7-10850H procesoriumi,
32 GB operatyviosios atminties ir Windows 10 operacine sistema.
Tyrimas buvo įgyvendintas C++ kalba su MinGW g++ 8.1.0 kompiliatoriumi naudojant -O3 optimizacijos lygį.

\section{Tarpų sekų efektyvumo įvertinimas}

Šį skyrių sudaro 2 poskyriai.
Pirmame poskyryje atliekant eksperimentus yra įvertinamas trumpų tarpų sekų efektyvumas.
Antrame poskyryje atliekant eksperimentus yra įvertinamas vidutinio ilgio tarpų sekų efektyvumas.

Iš anksto verta pastebėti, jog ne visos šiame skyriuje tiriamos tarpų sekos iš tiesų yra būtent tokio ilgio, koks pateikiamas šiame darbe.
Tačiau būtina atsižvelgti į faktą, jog tai galėtų sukelti nelygias sąlygas atliekamuose matavimuose,
kadangi seka, turinti elementų didesnių už maksimalų tiriamą $N$, atliktų nereikalingas operacijas, o per trumpa seka veiktų neefektyviai.
Siekiant standartizuoti tarpų sekų ilgius, buvo pasirinkta kai kurias sekas sutrumpinti (ar pratęsti, jei tam yra žinoma rekursyvi formulė)
taip, jog standartizuota seka būtų ilgiausia įmanoma seka, kurios visi elementai mažesni už maksimalų tiriamą $N$.

Atliekamų matavimų skaičius buvo pasirinktas atsižvelgiant į tame etape tiriamo $N$ dydį: jei $N$ labai mažas,
egzistuoja didelė tikimybė jog gautas vidutinis įvertis bus netikslus, matuojant, pavyzdžiui, tik 1000 kartų.
Todėl tiriant trumpesnes sekas buvo stengtasi atlikti daugiau matavimų.

Siekiant tiksliau įvertinti sekų efektyvumą, eksperimentai buvo atlikti
naudojant ir VŠA, ir PŠA.

\subsection{Trumpų tarpų sekų efektyvumo įvertinimas}

Trumpų tarpų sekų efektyvumo tyrimui buvo pasirinktos šios tarpų sekos:
\begin{itemize}
  \item Tokuda: $525, 233, 103, 46, 20, 9, 4, 1$ \cite{10.5555/645569.659879}
  \item Ciura: $701, 301, 132, 57, 23, 10, 4, 1$ \cite{ciura2001best}
  \item Simpson-Yachavaram: $893, 219, 83, 36, 13, 4, 1$ \cite{simpson1999faster}
  \item Sedgewick: $929, 505, 209, 109, 41, 19, 5, 1$ \cite{SEDGEWICK1986159}
  \item Incerpi-Sedgewick: $861, 336, 112, 48, 21, 7, 3, 1$ \cite{incerpi1985improved}
  \item S1: $855, 264, 86, 35, 12, 5, 1$
\end{itemize}

Atsižvelgiant į santykinai nedidelį duomenų dydį, matavimai buvo atlikti 50000 kartų.
Gauti duomenys pateikiami suapvalinus iki šimtosios dalies,
3 geriausi rezultatai su tam tikru $N$ pateikiami pajuodintu šriftu.

\subsubsection{Efektyvumo tyrimas naudojant vadovėlinį Šelo algoritmą}

\begin{table}[H]
  \caption{Vidutinis VŠA atliktų palyginimų skaičius naudojant trumpas tarpų sekas}
  \label{tss_small_comparisons}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda  & Ciura            & S/Y              & Sedgewick & I/S     & S1               \\ \hline
  50   & 289.90  & \textbf{287.76}  & \textbf{287.70}  & 293.41    & 296.37  & \textbf{289.21}  \\ \hline
  100  & 735.82  & \textbf{733.35}  & \textbf{731.49}  & 752.13    & 759.57  & \textbf{731.87}  \\ \hline
  200  & 1812.59 & \textbf{1797.92} & \textbf{1798.5}  & 1840.15   & 1870.94 & \textbf{1793.19} \\ \hline
  400  & 4315.6  & \textbf{4276.38} & \textbf{4284.94} & 4405.07   & 4464.59 & \textbf{4273.84} \\ \hline
  800  & 10061.3 & \textbf{9946.54} & \textbf{9987.18} & 10260.5   & 10528.2 & \textbf{9999.9}  \\ \hline
  1000 & 13128.9 & \textbf{13044.4} & \textbf{13075.4} & 13395.4   & 13807.4 & \textbf{13054.4} \\ \hline
  \end{tabular}
\end{table}

Kaip galima pastebėti iš \ref{tss_small_comparisons} lentelės, mažiausiai palyginimų bendru atveju atliko Ciura seka,
šiek tiek daugiau - S1 ir Simpson-Yachavaram sekos.
Vidutiniški rezultatai gauti su Tokuda seka.
Daugiausiai palyginimų atliko Sedgewick ir Incerpi-Sedgewick sekos.

\begin{table}[H]
  \caption{Vidutinis VŠA atliktų priskyrimų skaičius naudojant trumpas tarpų sekas}
  \label{tss_small_assignments}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda  & Ciura   & S/Y              & Sedgewick        & I/S     & S1               \\ \hline
  50   & 482.37  & 473.17  & \textbf{453.48}  & \textbf{447.69}  & 487.44  & \textbf{456.58}  \\ \hline
  100  & 1204.5  & 1186.33 & \textbf{1137.21} & \textbf{1130.61} & 1227.55 & \textbf{1135.35} \\ \hline
  200  & 2933.02 & 2862.17 & \textbf{2752.73} & \textbf{2761.21} & 2977.03 & \textbf{2745.81} \\ \hline
  400  & 6898.23 & 6733.29 & \textbf{6522.93} & \textbf{6629.27} & 6903.13 & \textbf{6444.15} \\ \hline
  800  & 15899.2 & 15487.9 & \textbf{14758.6} & \textbf{15354.8} & 15950   & \textbf{14745.8} \\ \hline
  1000 & 20707.8 & 20273.4 & \textbf{19200.7} & \textbf{20089.7} & 20841.4 & \textbf{19193.6} \\ \hline
  \end{tabular}
\end{table}

Mažiausiai priskyrimų, remiantis \ref{tss_small_assignments} lentele, atliko S1 seka.
Nežymiai daugiau - Simpson-Yachavaram ir Sedgewick sekos.
Vidutiniški rezultatai gauti su Tokuda seka.
Daugiausiai priskyrimų atliko Tokuda ir Incerpi-Sedgewick sekos.

\begin{table}[H]
  \caption{Vidutinis VŠA veikimo laikas (μs) naudojant trumpas tarpų sekas}
  \label{tss_small_runtimes}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda        & Ciura          & S/Y            & Sedgewick      & I/S            & S1             \\ \hline
  50   & \textbf{1.00} & 1.02           & 1.10           & \textbf{1.01}  & 1.14           & \textbf{0.90}  \\ \hline
  100  & 3.04          & \textbf{2.87}  & \textbf{2.75}  & 2.95           & \textbf{2.74}  & 3.09           \\ \hline
  200  & 6.35          & \textbf{6.25}  & \textbf{6.32}  & \textbf{6.00}  & 7.20           & 6.37           \\ \hline
  400  & 16.39         & 15.06          & \textbf{14.29} & \textbf{14.20} & \textbf{14.77} & 14.92          \\ \hline
  800  & 39.93         & \textbf{37.60} & \textbf{35.41} & 38.60          & 43.22          & \textbf{33.30} \\ \hline
  1000 & 45.74         & 44.30          & \textbf{42.07} & \textbf{42.58} & 44.44          & \textbf{44.10} \\ \hline
  \end{tabular}
\end{table}

Vertinant vidutinį veikimo laiką, pateiktą \ref{tss_small_runtimes} lentelėje,
geriausi rezultatai gauti su Sedgewick ir Simpson-Yachavaram sekomis.
Taip pat pakankamai geri rezultatai gauti su Ciura ir S1 sekomis.
Prasčiausi vidutinio veikimo laiko rezultatai, imant bendrai, gauti su Incerpi-Sedgewick ir Tokuda sekomis.

Įvertinant visus kriterijus, šiame etape geriausi rezultatai gauti su Ciura, S1 ir Simpson-Yachavaram sekomis.

\subsubsection{Efektyvumo tyrimas naudojant patobulintą Šelo algoritmą}

\begin{table}[H]
  \caption{Vidutinis PŠA atliktų palyginimų skaičius naudojant trumpas tarpų sekas}
  \label{iss_small_comparisons}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda   & Ciura             & S/Y               & Sedgewick & I/S      & S1                \\ \hline
  50   & 289.85   & \textbf{287.85}   & \textbf{287.83}   & 293.70    & 296.33   & \textbf{289.09}   \\ \hline
  100  & 736.17   & \textbf{733.32}   & \textbf{731.70}   & 751.94    & 759.47   & \textbf{732.01}   \\ \hline
  200  & 1812.48  & \textbf{1798.04}  & \textbf{1798.66}  & 1840.66   & 1871.29  & \textbf{1793.03}  \\ \hline
  400  & 4315.89  & \textbf{4276.20}  & \textbf{4284.83}  & 4405.79   & 4464.40  & \textbf{4273.78}  \\ \hline
  800  & 10061.00 & \textbf{9945.74}  & \textbf{9986.13}  & 10259.80  & 10525.90 & \textbf{9999.26}  \\ \hline
  1000 & 13130.80 & \textbf{13044.10} & \textbf{13077.20} & 13393.00  & 13807.50 & \textbf{13053.10} \\ \hline
  \end{tabular}
\end{table}

Analizuojant atliktų palyginimų skaičių, pateikiamą \ref{iss_small_comparisons} lentelėje,
galima pastebėti, jog mažiausiai palyginimų atliko Ciura seka.
Geresni nei vidutiniški rezultatai gauti S1 ir Simpson-Yachavaram sekomis.
Vidutiniški rezultatai gauti su Tokuda seka.
Daugiausiai palyginimų atliko Sedgewick ir Incerpi-Sedgewick sekos.

\begin{table}[H]
  \caption{Vidutinis PŠA atliktų priskyrimų skaičius naudojant trumpas tarpų sekas}
  \label{iss_small_assignments}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda            & Ciura             & S/Y             & Sedgewick         & I/S             & S1                \\ \hline
  50   & \textbf{312.13}   & \textbf{319.66}   & 322.80          & 335.37            & \textbf{322.30} & 323.76            \\ \hline
  100  & \textbf{791.06}   & \textbf{797.73}   & \textbf{811.35} & 853.82            & 822.16          & 814.18            \\ \hline
  200  & \textbf{1931.99}  & \textbf{1919.31}  & 1999.55         & 2061.03           & 1998.26         & \textbf{1996.21}  \\ \hline
  400  & \textbf{4537.96}  & \textbf{4545.12}  & 4731.20         & 4855.45           & 4767.84         & \textbf{4720.75}  \\ \hline
  800  & \textbf{10502.10} & \textbf{10587.70} & 11134.90        & \textbf{11121.30} & 11396.80        & 11222.50          \\ \hline
  1000 & \textbf{13866.10} & \textbf{13819.40} & 14510.70        & 14523.70          & 14868.70        & \textbf{14490.70} \\ \hline
  \end{tabular}
\end{table}

Kaip galima pastebėti \ref{iss_small_assignments} lentelėje, mažiausiai priskyrimų atliko Tokuda ir Ciura sekos.
Vidutiniški rezultatai gauti su S1 ir Simpson-Yachavaram sekomis.
Daugiausiai priskyrimų atliko Sedgewick ir Incerpi-Sedgewick sekos.

\begin{table}[H]
  \caption{Vidutinis PŠA veikimo laikas (μs) naudojant trumpas tarpų sekas}
  \label{iss_small_runtimes}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda        & Ciura         & S/Y            & Sedgewick      & I/S   & S1             \\ \hline
  50   & 1.30          & \textbf{1.26} & \textbf{1.02}  & 1.32           & 1.32  & \textbf{1.14}  \\ \hline
  100  & \textbf{3.16} & \textbf{3.16} & \textbf{3.14}  & \textbf{3.02}  & 3.36  & 3.22           \\ \hline
  200  & \textbf{7.54} & 7.95          & \textbf{7.54}  & \textbf{7.61}  & 8.11  & 8.00           \\ \hline
  400  & 18.52         & 19.00         & \textbf{17.67} & \textbf{17.29} & 18.92 & \textbf{18.18} \\ \hline
  800  & 42.96         & 42.60         & \textbf{41.81} & \textbf{40.67} & 42.23 & \textbf{41.19} \\ \hline
  1000 & 56.69         & 56.88         & \textbf{53.39} & \textbf{53.45} & 56.38 & \textbf{52.84} \\ \hline
  \end{tabular}
\end{table}

Geriausi vidutiniai veikimo laikai, remiantis \ref{iss_small_runtimes} lentele, gauti su Sedgewick ir Simpson-Yachavaram sekomis.
Geresni nei vidutiniai rezultatai gauti su S1 seka,
vidutiniški - su Tokuda ir Ciura sekomis.
Ilgiausiai bendru atveju veikė Incerpi-Sedgewick seka.

Įvertinant visus kriterijus, geriausi rezultatai gauti su Tokuda, Ciura ir S1 sekomis.


\subsubsection{Gautų rezultatų apibendrinimas}

Verta pastebėti, jog patobulintas Šelo algoritmas atliekamų palyginimų skaičiumi teoriškai neturėtų skirtis nuo vadovėlinės implementacijos,
tad gauti įverčiai leidžia įvertinti matavimų tikslumą atspindint vidutiniu atveju atliekamų palyginimų skaičių naudojant šias tarpų sekas.
Atsižvelgiant į gautus rezultatus, galima teigti, jog matavimai buvo pakankamai tikslūs, kadangi atliktų palyginimų įverčiai naudojant VŠA ir PŠA skiriasi labai nedaug.
Taip pat galima pastebėti, jog Ciura seka atlieka mažiausiai palyginimų vidutiniu atveju, kai $N \leq 1000$, kaip ir teigta \cite{ciura2001best}.

Gauti rezultatai rodo, jog PŠA atlieka žymiai mažiau priskyrimų, nei VŠA - kaip ir teigė \cite{Radavičius_Baranauskas_2013} autoriai.
Tirtame rėžyje gauti įverčiai skiriasi apie 25-40\%, priklausomai nuo tarpų sekos ir duomenų dydžio.
Taip pat verta pastebėti, jog su PŠA atliktų palyginimų ir priskyrimų skaičiaus santykis artėja prie 1 augant N, priešingai nei naudojant VŠA.

Remiantis šiame tyrimo etape gautais rezultatais, galima pastebėti, jog beveik visi naudojant VŠA gauti veikimo laikai yra geresni už tuos, gautus naudojant PŠA
ir kai kuriais atvejais veikimo laikų skirtumai siekia net 20\%.
Tai yra neįprasta, kadangi lyginant su VŠA, PŠA atlieka apytiksliai tiek pat palyginimų ir žymiai mažiau priskyrimų.
Reikia pabrėžti, jog veikimo laiko įverčiai, ypač su mažesniais duomenų dydžiais, nėra labai tikslūs ir priklauso nuo daugelio veiksnių.
Tačiau atsižvelgiant į pastebimai prastesnius veikimo laikus, sunku rekomenduoti PŠA nesudėtingų tipų duomenų rikiavimui, kai $N \leq 1000$.
Rikiuojant duomenis, kurių priskyrimas brangus, PŠA veikimo laikas tikėtinai būtų geresnis, kadangi jį naudojant atliekama mažiau priskyrimų, tačiau tuo įsitikinti reikėtų atskiro tyrimo.  
 
Galima teigti, jog GA naudojimas trumpų tarpų sekų generavimui duoda gerus rezultatus, kadangi abi GA sugeneruotos sekos (Simpson-Yachavaram ir S1)
vidutiniu atveju atliko daugiau palyginimų tik už Ciura seką ir buvo vienos geriausių vertinant atliktų priskyrimų skaičių naudojant VŠA bei vidutinį veikimo laiką.
Tiesa, GA sugeneruotos sekos nėra be trūkumų: lyginant su Tokuda ir Ciura sekomis, kurios atlieka daugiau priskyrimų naudojant VŠA, GA sugeneruotos sekos atlieka žymiai daugiau priskyrimų
naudojant PŠA. Tai sukelia klausimų dėl jų efektyvumo, kadangi PŠA pašalina tik nereikalingai atliekamus priskyrimus.

Apibendrinant, efektyviausios šiame etape vertintos sekos yra Ciura ir S1,
nes abiejose efektyvumo tyrimo dalyse jas naudojant gauti rezultatai buvo vieni geriausių.


\subsection{Vidutinio ilgio tarpų sekų efektyvumo įvertinimas}

Vidutinio ilgio tarpų sekų efektyvumo tyrimui buvo pasirinktos šios tarpų sekos:
\begin{itemize}
  \item Tokuda: $68178,30301,13467,5985,2660,1182,525,233,103,46,20,9,4,1$ \cite{10.5555/645569.659879}
  \item Ciura: $90927,40412,17961,7983,3548,1577,701,301,132,57,23,10,4,1$ \cite{ciura2001best}
  \item Simpson-Yachavaram: $38291,22927,8992,3568,1488,893,219,83,36,13,4,1$ \cite{simpson1999faster}
  \item Incerpi-Sedgewick: $86961,33936,13776,4592,1968,861,336,112,48,21,7,3,1$ \cite{incerpi1985improved}
  \item Sedgewick: $64769,36289,16001,8929,3905,2161,929,505,209,109,41,19,5,1$ \cite{SEDGEWICK1986159}
  \item Roos et al.: $91433,72985,13229,5267,2585,877,155,149,131,23,8,1$ \cite{roos2002genetic}
  \item S2: $45794,17396,7414,3136,1206,561,264,86,35,12,5,1$
\end{itemize}

Atsižvelgiant į duomenų dydį, matavimai buvo atlikti 10000 kartų.
Gauti duomenys pateikiami suapvalinus iki sveikosios dalies,
3 geriausi rezultatai su tam tikru $N$ pateikiami pajuodintu šriftu.

\subsubsection{Efektyvumo tyrimas naudojant vadovėlinį Šelo algoritmą}

\begin{table}[H]
  \caption{Vidutinis VŠA atliktų palyginimų skaičius naudojant vidutinio ilgio tarpų sekas}
  \label{tss_medium_comparisons}
  \begin{tabular}{|l|l|l|l|l|l|l|l|}
  \hline
  N      & Tokuda           & Ciura            & S/Y     & I/S     & Sedgewick & R/B/H/Z & S2               \\ \hline
  5000   & \textbf{86930}   & \textbf{86490}   & 88075   & 93869   & 89056     & 102065  & \textbf{87131}   \\ \hline
  10000  & \textbf{192625}  & \textbf{191703}  & 195221  & 209514  & 197067    & 225459  & \textbf{193092}  \\ \hline
  20000  & \textbf{423598}  & \textbf{421301}  & 429228  & 465748  & 433320    & 493530  & \textbf{423824}  \\ \hline
  40000  & \textbf{922922}  & \textbf{918490}  & 936240  & 1032259 & 943633    & 1070908 & \textbf{923609}  \\ \hline
  80000  & \textbf{1999095} & \textbf{1992131} & 2033327 & 2273358 & 2045446   & 2317061 & \textbf{2002290} \\ \hline
  100000 & \textbf{2564038} & \textbf{2552126} & 2605061 & 2923557 & 2623763   & 2959526 & \textbf{2563334} \\ \hline
  \end{tabular}
\end{table}

Kaip galima pastebėti \ref{tss_medium_comparisons} lentelėje, mažiausiai palyginimų bendru atveju atliko Ciura seka,
šiek tiek daugiau - Tokuda ir S2 sekos.
Vidutiniški rezultatai gauti su Simpson-Yachavaram ir Sedgewick sekomis.
Daugiausiai palyginimų atliko Incerpi-Sedgewick ir Roos et al. sekos.

\begin{table}[H]
  \caption{Vidutinis VŠA atliktų priskyrimų skaičius naudojant vidutinio ilgio tarpų sekas}
  \label{tss_medium_assignments}
  \begin{tabular}{|l|l|l|l|l|l|l|l|}
  \hline
  N      & Tokuda  & Ciura            & S/Y              & I/S     & Sedgewick & R/B/H/Z & S2               \\ \hline
  5000   & 134747  & \textbf{132482}  & \textbf{129043}  & 138209  & 133685    & 140459  & \textbf{129181}  \\ \hline
  10000  & 296787  & \textbf{292056}  & \textbf{284474}  & 306461  & 295196    & 311298  & \textbf{284895}  \\ \hline
  20000  & 648807  & \textbf{638480}  & \textbf{623546}  & 672463  & 650675    & 680242  & \textbf{622844}  \\ \hline
  40000  & 1407318 & \textbf{1385991} & \textbf{1358871} & 1473610 & 1414589   & 1466640 & \textbf{1352658} \\ \hline
  80000  & 3034012 & \textbf{3001389} & \textbf{2959087} & 3214096 & 3072581   & 3127946 & \textbf{2925254} \\ \hline
  100000 & 3888404 & \textbf{3836014} & \textbf{3777087} & 4124557 & 3941499   & 4007456 & \textbf{3735445} \\ \hline
  \end{tabular}
\end{table}

Mažiausiai priskyrimų, remiantis \ref{tss_medium_assignments} lentele, atliko Simpson-Yachavaram ir S2 sekos.
Nedaug atsiliko Ciura seka.
Vidutiniški rezultatai gauti su Tokuda ir Sedgewick sekomis.
Daugiausiai priskyrimų atliko Incerpi-Sedgewick ir Roos et al. sekos.

\begin{table}[H]
  \caption{Vidutinis VŠA veikimo laikas (μs) naudojant vidutinio ilgio tarpų sekas}
  \label{tss_medium_runtimes}
  \begin{tabular}{|l|l|l|l|l|l|l|l|}
  \hline
  N      & Tokuda & Ciura        & S/Y            & I/S   & Sedgewick     & R/B/H/Z       & S2            \\ \hline
  5000   & 312    & \textbf{310} & \textbf{294}   & 330   & 311           & \textbf{296}  & 314           \\ \hline
  10000  & 707    & 702          & \textbf{671}   & 690   & 695           & \textbf{618}  & \textbf{688}  \\ \hline
  20000  & 1611   & 1550         & 1515           & 1577  & \textbf{1484} & \textbf{1345} & \textbf{1477} \\ \hline
  40000  & 4207   & 4274         & \textbf{4067}  & 4273  & 4239          & \textbf{3728} & \textbf{4135} \\ \hline
  80000  & 9638   & 9363         & \textbf{8541}  & 9064  & 9132          & \textbf{8058} & \textbf{8745} \\ \hline
  100000 & 13810  & 12058        & \textbf{11077} & 11652 & 11976         & \textbf{9225} & \textbf{9314} \\ \hline
  \end{tabular}
\end{table}

Geriausi veikimo laikai, pateikiami \ref{tss_medium_runtimes} lentelėje, pastebimi su Roos et al. seka.
S2 ir Simpson-Yachavaram sekų rezultatai taip pat geri.
Vidutiniški rezultatai gauti su Incerpi-Sedgewick, Sedgewick ir Ciura sekomis.
Ilgiausiai veikė Tokuda seka.

Vertinant visus kriterijus, geriausi rezultatai gauti su Ciura, Tokuda ir S2 sekomis.

\subsubsection{Efektyvumo tyrimas naudojant patobulintą Šelo algoritmą}

\begin{table}[H]
  \caption{Vidutinis PŠA atliktų palyginimų skaičius naudojant vidutinio ilgio tarpų sekas}
  \label{iss_medium_comparisons}
  \begin{tabular}{|l|l|l|l|l|l|l|l|}
  \hline
  N      & Tokuda           & Ciura            & S/Y     & I/S     & Sedgewick & R/B/H/Z & S2               \\ \hline
  5000   & \textbf{86926}   & \textbf{86499}   & 88071   & 93852   & 89060     & 102054  & \textbf{87125}   \\ \hline
  10000  & \textbf{192624}  & \textbf{191711}  & 195229  & 209574  & 197045    & 225524  & \textbf{193106}  \\ \hline
  20000  & \textbf{423593}  & \textbf{421326}  & 429232  & 465791  & 433302    & 493515  & \textbf{423825}  \\ \hline
  40000  & \textbf{922899}  & \textbf{918450}  & 936191  & 1032317 & 943633    & 1071022 & \textbf{923625}  \\ \hline
  80000  & \textbf{1998794} & \textbf{1992412} & 2033313 & 2272227 & 2045555   & 2317464 & \textbf{2002261} \\ \hline
  100000 & \textbf{2564388} & \textbf{2551823} & 2605193 & 2923248 & 2624057   & 2959855 & \textbf{2563352} \\ \hline
  \end{tabular}
\end{table}

Remiantis rezultatais, pateikiamais \ref{iss_medium_comparisons} lentelėje,
mažiausiai palyginimų su visais duomenų dydžiais atliko Ciura seka.
Geresni nei vidutiniai rezultatai gauti su Tokuda ir S2 sekomis.
Vidutiniški rezultatai gauti su Simpson-Yachavaram ir Sedgewick sekomis.
Daugiausiai palyginimų atliko Incerpi-Sedgewick ir Roos et al. sekos.

\begin{table}[H]
  \caption{Vidutinis PŠA atliktų priskyrimų skaičius naudojant vidutinio ilgio tarpų sekas}
  \label{iss_medium_assignments}
  \begin{tabular}{|l|l|l|l|l|l|l|l|}
  \hline
  N      & Tokuda           & Ciura            & S/Y     & I/S     & Sedgewick        & R/B/H/Z & S2      \\ \hline
  5000   & \textbf{91607}   & \textbf{91536}   & 96002   & 101234  & \textbf{94353}   & 110577  & 94638   \\ \hline
  10000  & \textbf{201994}  & \textbf{202938}  & 213152  & 226716  & \textbf{208567}  & 243602  & 209125  \\ \hline
  20000  & \textbf{443461}  & \textbf{447218}  & 469964  & 503670  & \textbf{455367}  & 529908  & 459749  \\ \hline
  40000  & \textbf{967300}  & \textbf{979059}  & 1019801 & 1120974 & \textbf{991883}  & 1161681 & 1005877 \\ \hline
  80000  & \textbf{2099578} & \textbf{2125122} & 2209278 & 2479564 & \textbf{2137726} & 2521194 & 2179979 \\ \hline
  100000 & \textbf{2691737} & \textbf{2709969} & 2831031 & 3181857 & \textbf{2741611} & 3209010 & 2796455 \\ \hline
  \end{tabular}
\end{table}

Vertinant atliktus priskyrimus, geriausi rezultatai, pateikiami \ref{iss_medium_assignments} lentelėje, buvo gauti su Tokuda seka.
Taip pat geri rezultatai gauti su Ciura ir Sedgewick sekomis.
Vidutiniški rezultatai gauti su Simpson-Yachavaram ir S2 sekomis.
Daugiausiai priskyrimų atliko Incerpi-Sedgewick ir Roos et al. sekos.

\begin{table}[H]
  \caption{Vidutinis PŠA veikimo laikas (μs) naudojant vidutinio ilgio tarpų sekas}
  \label{iss_medium_runtimes}
  \begin{tabular}{|l|l|l|l|l|l|l|l|}
  \hline
  N      & Tokuda         & Ciura          & S/Y           & I/S   & Sedgewick    & R/B/H/Z        & S2            \\ \hline
  5000   & \textbf{289}   & \textbf{284}   & 307           & 325   & 335          & \textbf{300}   & 301           \\ \hline
  10000  & 758            & 773            & 732           & 753   & \textbf{666} & \textbf{601}   & \textbf{716}  \\ \hline
  20000  & \textbf{1559}  & 1635           & 1594          & 1628  & 1647         & \textbf{1468}  & \textbf{1523} \\ \hline
  40000  & 3810           & 3483           & \textbf{3426} & 3630  & 3451         & \textbf{3124}  & \textbf{3441} \\ \hline
  80000  & 8956           & 8875           & \textbf{8077} & 9163  & 9153         & \textbf{7673}  & \textbf{8767} \\ \hline
  100000 & \textbf{11080} & \textbf{11200} & 11228         & 12138 & 12006        & \textbf{10361} & 11283         \\ \hline
  \end{tabular}
\end{table}

Nagrinėjant vidutinį veikimo laiką, pateikiamą \ref{iss_medium_runtimes} lentelėje, bendru atveju greičiausiai veikė Roos et al. seka.
Sekos S2 rezultatai taip pat pakankamai geri.
Vidutiniški rezultatai gauti su Simpson-Yachavaram, Tokuda ir Ciura sekomis.
Lėčiausiai veikė Incerpi-Sedgewick ir Sedgewick sekos.

Vertinant visus kriterijus, geriausi rezultatai gauti su Ciura ir Tokuda sekomis.

\subsubsection{Gautų rezultatų apibendrinimas}

Kaip ir tiriant trumpas tarpų sekas, VŠA ir PŠA atliekamų palyginimų įverčiai beveik nesiskiria - 
net ir su $N = 100000$, maksimalus skirtumas yra mažesnis nei 1\%, tad galima teigti, jog atlikti matavimai buvo pakankamai tikslūs.

Pagal gautus rezultatus, Ciura seka atliko mažiausiai palyginimų, kas dalinai pateisina autoriaus spėjimą \cite{ciura2001best},
jog seką $701,301,132,57,23,10,4,1$ pratęsus bus gauta palyginimų atžvilgiu optimali seka ir didesniems $N$.

Kaip ir tiriant trumpas tarpų sekas, PŠA atlieka ženkliai mažiau priskyrimų, nei VŠA.
Tirtame rėžyje gauti įverčiai skiriasi apie 25-40\%, priklausomai nuo tarpų sekos ir duomenų dydžio.
Naudojant PŠA atliktų palyginimų ir priskyrimų skaičiaus santykis toliau artėja prie 1 augant $N$.

Kitaip nei tiriant trumpas tarpų sekas, PŠA veikimo laikai šioje tyrimo dalyje yra palankesni.
Tiesa, su tam tikromis tarpų sekomis pastebimi atvejai, kuriais PŠA veikia iki 20\% lėčiau, nei VŠA.
Tačiau duomenų dydžiui augant, palyginimų atžvilgiu optimalios sekos (Tokuda ir Ciura) naudojant PŠA veikia 5-20\% greičiau, nei naudojant VŠA.
Remiantis šiais ir anksčiau pateiktais pastebėjimais, galima daryti išvadą, jog PŠA negarantuoja geresnio veikimo laiko.
Pagal gautus duomenis, PŠA atliekant tą patį operacijų skaičių veikia lėčiau, nei VŠA, tad geresnis veikimo laikas pastebimas tik su sekomis,
kurių atliekamas priskyrimų skaičius naudojant PŠA stipriai sumažėja.

Gauti rezultatai rodo, jog Roos et al. seka, kaip ir teigta \cite{roos2002genetic},
veikia greičiau už Sedgewick ir Simpson-Yachavaram sekas, bent jau kai $N \leq 100000$, o pradiniai duomenys - sveiki skaičiai.
Iš tiesų, ši seka pagal gautus rezultatus yra absoliuti lyderė vertinant vidutinį veikimo laiką, tačiau būtina atsižvelgti į faktą, jog ji atlieka labai daug operacijų,
tad yra tikėtina, jog rikiuojant duomenis, kurių priskyrimas ar palyginimas yra brangus, gauti veikimo laiko rezultatai nebūtų tokie palankūs.

Simpson-Yachavaram seka, kaip ir teigė \cite{simpson1999faster} autoriai, su visais duomenų dydžiais atlieka mažiau palyginimų ir bendru atveju veikia greičiau, nei Sedgewick seka.
Reikia pastebėti, jog naudojant VŠA Simpson-Yachavaram seka atlieka mažiau priskyrimų nei Sedgewick seka su visais duomenų dydžiais, bet
naudojant PŠA situacija yra visiškai priešinga.
Įvertinant gautus rezultatus, darosi aišku, jog sekos, kurios su VŠA atlieka labai mažai priskyrimų, su PŠA didelės naudos negauna, kadangi ir taip
vienu ar kitu būdu atlieka mažiau nereikalingų priskyrimų. Taip pat galima daryti prielaidą, jog šios optimizacijos kaina yra didesnis
priskyrimų, atliekamų iš tikrųjų sukeičiant elementus, skaičius, kurį ir galima pastebėti naudojant PŠA. 

Galima teigti, jog GA naudojimas vidutinio ilgio tarpų sekų generavimui duoda pakankamai gerus rezultatus: nors nė viena iš GA sugeneruotų sekų (Simpson-Yachavaram, Roos et al. ir S2) nelenkia Tokuda ir Ciura sekų
vertinant atliktus palyginimus, S2 ir Simpson-Yachavaram sekos naudojant VŠA atlieka mažiau priskyrimų, o Roos et al. seka, kaip ir minėta anksčiau, veikia labai greitai.

Apibendrinant, efektyviausios šiame etape vertintos sekos yra Ciura ir Tokuda, kadangi tiek su VŠA, tiek su PŠA 
naudojant jas buvo gauti geriausi rezultatai.

\sectionnonum{Išvados}

Sunku nuspręsti, ar galima rekomenduoti patobulintą Šelo algoritmą praktiniams taikymams visais atvejais. 
Viena vertus, gauti rezultatai rodo, jog šis algoritmas tikrai atlieka mažiau priskyrimų, nei vadovėlinė implementacija.
Kita vertus, gauti vidutinio veikimo laiko įverčiai yra nenuspėjami ir kai kuriais atvejais blogesni, nei vadovėlinės implementacijos.
Panašu, jog norint atsakyti į šį klausimą, reikėtų atskiro PŠA ir VŠA veikimo laiko tyrimo, kurį taip pat derėtų atlikti sistemoje, leidžiančioje tiksliai išmatuoti
panaudotą procesoriaus laiką.

Reikia pastebėti, jog tarpų sekų efektyvumo vertinimui patobulintas Šelo algoritmas yra tinkamesnis.
Kadangi šis algoritmas pašalina nereikalingai atliekamus priskyrimus, yra daug lengviau nustatyti, kurios tarpų sekos yra efektyviausios,
kadangi atliekamų priskyrimų skaičius naudojant šį algoritmą priklauso tik nuo pačios tarpų sekos.
Tokiu būdu vertinant sekas galima atsiriboti nuo konkrečios implementacijos subtilybių, laikant jog efektyvi seka paprasčiausiai turi atlikti kuo mažiau palyginimų ir priskyrimų.

Įvertinant gautus rezultatus, galima teigti, jog genetiniai algoritmai yra tinkamas metodas efektyvių tarpų sekų radimui.
Darbo metu sugeneruotos tarpų sekos S1 ir S2 lyginant su literatūroje pateiktomis sekomis pasirodė gerai, tačiau nėra efektyviausios.
% Tiesa, naudojant vadovėlinį Šelo algoritmą jas tikrai galima rekomenduoti, kadangi šiuo atveju jos atlieka pakankamai mažai palyginimų, mažiausiai priskyrimų bei veikia greitai.
Autoriaus nuomone, tai tikrai nėra geriausios sekos, kurias galima sugeneruoti naudojant genetinius algoritmus - ateityje
pasitelkiant darbo metu įgytas žinias būtų galima tarpų sekų generavimo procesą patobulinti.
Pavyzdžiui, siekiant rasti efektyvesnes sekas, galėtų būti parengtas genetinis algoritmas, kuris naudojant patobulintą Šelo algoritmą
optimizuotų tarpų sekų atliekamus palyginimus ir priskyrimus.

Bendru atveju galima rekomenduoti Ciura tarpų seką, kadangi ji remiantis atliktu vertinimu yra efektyviausia.
Tiesa, nėra visiškai aišku, kas prarandama renkantis mažiau efektyvią tarpų seką.
Pavyzdžiui, Roos et al. tarpų seka yra neefektyvi (atlieka labai daug operacijų), tačiau veikia greičiau už kitas tirtas tarpų sekas.
Ieškant atsakymo į šį klausimą, reikėtų ištirti Šelo algoritmo veikimo laiko priklausomybę nuo rikiuojamų duomenų tipo,
kas leistų įvertinti, kokią įtaką veikimo laikui turi palyginimo ir priskyrimo operacijų kaina.

Šelo algoritmu rikiuojant nedidelius ($N \leq 1000$) duomenų dydžius,
galima rekomenduoti Ciura ir S1 tarpų sekas, kadangi jos atlieka mažiausiai palyginimų ir yra efektyviausios.
Atsižvelgiant į prastesnį patobulinto Šelo algoritmo veikimo laiką,
rekomenduojama rinktis vadovėlinę Šelo algoritmo versiją.

Šelo algoritmu rikiuojant didesnius ($1000 \leq N \leq 100000$) duomenų dydžius, galima rekomenduoti Ciura ir Tokuda tarpų sekas,
kadangi jos atlieka mažiausiai palyginimų ir yra efektyviausios.
Taip pat šiuo atveju galima rekomenduoti ir patobulintą Šelo algoritmo versiją,
kadangi ją pasitelkiant atliekama mažiau priskyrimų bei dažnu atveju pastebimas geresnis veikimo laikas, nei naudojant vadovėlinę versiją.


% aprasyti, ka galima atlikti toliau 

% Išvadose ir pasiūlymuose, nekartojant atskirų dalių apibendrinimų,
% suformuluojamos svarbiausios darbo išvados, rekomendacijos bei pasiūlymai.

\printbibliography[heading=bibintoc] % Literatūros šaltiniai

% \appendix  % Priedai
% Prieduose gali būti pateikiama pagalbinė, ypač darbo autoriaus savarankiškai
% parengta, medžiaga. Savarankiški priedai gali būti pateikiami kompiuterio
% diskelyje ar kompaktiniame diske. Priedai taip pat vadinami ir numeruojami.
% Tekstas su priedais siejamas nuorodomis (pvz.: \ref{img:mlp}).

\end{document}
