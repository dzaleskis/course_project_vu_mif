\documentclass{VUMIFInfKursinis}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{color}
\usepackage{graphicx}
\usepackage{hyperref}  % Nuorodų aktyvavimas
\usepackage{url}

\algnewcommand\algorithmicforeach{\textbf{foreach}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

% Titulinio aprašas
\university{Vilniaus universitetas}
\faculty{Matematikos ir informatikos fakultetas}
\institute{Informatikos institutas}  % Užkomentavus šią eilutę - institutas neįtraukiamas į titulinį
\department{Informatikos katedra}
\papertype{Kursinis darbas}
\title{Rikiavimo tobulinimas genetiniais algoritmais}
\titleineng{Improving sorting with genetic algorithms}
\status{3 kurso 2 grupės studentas}
\author{Deividas Zaleskis}
\supervisor{Irmantas Radavičius}
\date{Vilnius \\ \the\year}

% Nustatymai
\bibliography{bibliografija} 

\begin{document}
\maketitle

\tableofcontents

\sectionnonum{Įvadas}

Viena pagrindinių informatikos sąvokų yra algoritmas.
Formaliai algoritmą galima apibūdinti kaip
baigtinę seką instrukcijų, nurodančių kaip rasti nagrinėjamo uždavinio sprendinį.
Algoritmo koncepcija egzistuoja nuo senovės laikų \cite{knuth1972ancient}, tačiau atsiradus kompiuteriams,
tapo įmanoma algoritmų vykdymą automatizuoti, paverčiant juos mašininiu kodu suprantamu kompiuteriams \cite{wilkes1951preparation}.
Taip informatikos mokslas nuo teorinių šaknų \cite{turing1937computable} įgavo ir taikomąją pusę.
Beveik visus algoritmus galima suskirstyti į dvi klases: kombinatorinius algoritmus ir skaitinius algoritmus.
Skaitiniai algoritmai sprendžia tolydžius uždavinius: optimizuoti realaus argumento funkciją, išspręsti tiesinių lygčių sistemą su realiais koeficientais, etc.
Kombinatoriniai algoritmai sprendžia diskrečius uždavinius ir operuoja diskrečiais objektais: skaičiais, sąrašais, grafais, etc.
Apibendrinant, sunku įsivaizduoti informatikos mokslą be algoritmo sąvokos.

Vienas žinomiausių diskretaus uždavinio pavyzdžių yra duomenų rikiavimas.
Matematiškai jis formuluojamas taip:
duotai baigtinei palyginamų elementų sekai $S = (s_1, s_2, ..., s_n)$ pateikti tokį
kėlinį, kad pradinės sekos elementai būtų išdėstyti didėjančia (mažėjančia) tvarka \cite{Radavičius_Baranauskas_2013}.
Rikiavimo uždavinys yra aktualus nuo pat kompiuterių atsiradimo ir buvo laikomas vienu 
pagrindinių diskrečių uždavinių, kuriuos turėtų gebėti spręsti kompiuteris \cite{10.1145/356580.356581}.
Rikiavimo uždavinio sprendimas dažnai padeda pagrindą efektyviam kito uždavinio sprendimui,
pavyzdžiui, atliekant paiešką sąraše, galima taikyti dvejetainės paieškos algoritmą tik tada,
kai sąrašas yra išrikiuotas.
Taigi rikiavimas yra vienas pamatinių informatikos uždavinių.

Rikiavimo algoritmų yra įvairių:
paremtų palyginimu (elementų tvarką nustato naudojant palyginimo operatorius),
stabilių (nekeičia lygių elementų tvarkos),
nenaudojančių papildomos atminties (atminties sudėtingumas yra $O(1)$), etc.
Asimptotiškai optimalūs palyginimu paremti algoritmai blogiausiu atveju turi $O(n\,log\,n)$ laiko sudėtingumą,
o ne palyginimu paremti algoritmai gali veikti dar greičiau, tačiau nėra tokie universalūs, kadangi rikiuojama remiantis duomenų specifika.
Tiesa, rikiuojant remtis vien algoritmo asimptotika nepakanka:
rikiavimas įterpimu (angl. insertion sort) blogiausiu atveju turi $O(n^2)$ laiko sudėtingumą \cite{bender2006insertion},
tačiau mažesnius elementų kiekius rikiuoja daug greičiau, nei asimptotiškai optimalūs algoritmai,
pavyzdžiui, rikiavimas krūva (angl. heapsort) \cite{10.1145/512274.512284}.
Todėl pastaruoju metu plačiai naudojami hibridiniai rikiavimo algoritmai, kurie sujungia keletą rikiavimo
algoritmų į vieną ir panaudoja jų geriausias savybes.
Nepaisant įvairovės ir naujų algoritmų gausos, klasikiniai rikiavimo algoritmai išlieka aktualūs.

Šelo rikiavimo algoritmas (angl. Shellsort, toliau - Šelo algoritmas) \cite{10.1145/368370.368387} yra paremtas palyginimu, nenaudojantis papildomos atminties ir nestabilus.
Šelo algoritmą galima laikyti rikiavimo įterpimu modifikacija,
kuri lygina ne gretimus, o toliau vienas nuo kito esančius elementus, taip paspartindama jų perkėlimą į galutinę poziciją.
Pagrindinė algoritmo idėja - išskaidyti rikiuojamą seką S į posekius $S_1, S_2, ..., S_n$,
kur kiekvienas posekis $S_i = (s_i, s_{i+h}, s_{i+2h}, ...)$ yra sekos S elementai, kurių pozicija skiriasi $h$.
Išrikiavus visus sekos $S$ posekius $S_i$ su tarpu $h$, seka tampa $h$-išrikiuota.
Remiantis tuo, jog sekai S esant $h$-išrikiuota ir ją $k$-išrikiavus, ji lieka $h$-išrikiuota \cite{GALE1972103},
galima kiekvieną algoritmo iteraciją mažinti tarpą, taip vis didinant sekos $S$ išrikiuotumą.
Pritaikant šias idėjas ir rikiavimui naudojant mažėjančią tarpų seką su paskutiniu nariu $1$,
kuris garantuoja rikiavimą įterpimu paskutinėje iteracijoje,
galima užtikrinti, jog algoritmo darbo pabaigoje seka S bus pilnai išrikiuota.
Įvertinant Šelo algoritmo idėjas, nesunku pastebėti tarpų sekų įtaką jo veikimui.

Šelo algoritmo efektyvumas tiesiogiai priklauso nuo pasirinktos tarpų sekos.
Weiss atlikto tyrimo \cite{weiss1991short} rezultatai rodo, jog su Sedgewick pasiūlyta seka
šis algoritmas veikia beveik dvigubai greičiau nei Šelo pradinis variantas, kai $n = 1000000$.
Yra įrodyta, kad Šelo algoritmo laiko sudėtingumo blogiausiu atveju apatinė riba yra
$\Omega(\frac{n\,log^2\,n}{log\,log\,n^2})$ \cite{267769}, taigi jis nėra asimptotiškai optimalus.
Tiesa, kol kas nėra rasta seka, su kuria Šelo algoritmas pasiektų šią apatinę ribą.
Kiek žinoma autoriui, asimptotiškai geriausia tarpų seka yra rasta Pratt, kuri yra formos
$2^p3^p$ ir turi $\Theta(n\,log^2\,n)$ laiko sudėtingumą blogiausiu atveju \cite{pratt1972shellsort},
tačiau praktikoje ji veikia lėčiau už Ciura \cite{ciura2001best} ar Tokuda \cite{10.5555/645569.659879} pasiūlytas sekas.
Daugelio praktikoje efektyvių sekų asimptotinis sudėtingumas laiko atžvilgiu lieka atvira problema,
nes jos yra rastos eksperimentiškai.
Todėl ir dabar yra tikslinga ieškoti naujų ir efektyvesnių Šelo algoritmo tarpų sekų.

Vienas iš metodų, kuriuos galima taikyti efektyvių tarpų sekų radimui, yra genetinis algoritmas.
Genetinis algoritmas (GA) yra metodas rasti euristikas, paremtas biologijos žiniomis apie natūralios atrankos procesą.
Kartu su genetiniu programavimu, evoliuciniais algoritmais ir kitais metodais, % citations needed
genetiniai algoritmai sudaro evoliucinių skaičiavimų šeimą.
Visi šios šeimos atstovai yra paremti pradinės populiacijos generavimu ir iteraciniu populiacijos atnaujinimu naudojant biologijos įkvėptas strategijas.
J.H. Holland, GA pradininkas, savo knygoje \cite{holland1992adaptation}
apibrėžė genetinio algoritmo sąvoką ir su ja glaudžiai susijusias
chromosomų (potencialių uždavinio sprendinių, išreikštų genų rinkiniu), bei
rekombinacijos (tėvinių chromosomų genų perdavimo palikuonims),
atrankos (tinkamiausių chromosomų atrinkimo) ir mutacijos (savaiminio chromosomos genų kitimo) operatorių koncepcijas.
Genetinių algoritmų veikimo strategija pagrįsta pradinės chromosomų populiacijos evoliucija, kiekvienos naujos chromosomų kartos
gavimui naudojant rekombinacijos, atrankos ir mutacijos operatorius.
Nesunku pastebėti, jog genetiniai algoritmai gali palengvinti tam tikrų rūšių uždavinių sprendimą.

Genetiniai algoritmai taikomi sprendžiant įvairius paieškos ir optimizavimo uždavinius, kuomet nesunku nustatyti, ar sprendinys tinkamas,
tačiau tinkamo sprendinio radimas reikalauja daug resursų ar net pilno perrinkimo.
Tokiu atveju apytikslio sprendinio radimas (euristika) gali būti daug patrauklesnis sprendimo būdas,
kadangi tikslaus sprendinio radimas dažnai yra NP-sunkus uždavinys.
Todėl GA yra pritaikomi sudarant grafikus ir tvarkaraščius,
sprendžiant globalaus optimizavimo uždavinius
ir net projektuojant NASA mikrosatelitų antenas \cite{hornby2006automated}.
Nesunku pastebėti, jog efektyvių Šelo algoritmo tarpų sekų radimas yra sunkus uždavinys atliekamų skaičiavimų prasme,
tikėtinai reikalaujantis pilno potencialių sprendinių perrinkimo,
tad šio uždavinio sprendimui taikyti GA yra prasminga.
Kiek žinoma autoriui, kol kas yra buvę du bandymai taikyti genetinius algoritmus efektyvių Šelo algoritmo tarpų sekų radimui \cite{simpson1999faster, roos2002genetic}.
Abiejuose darbuose teigiama, jog genetiniais algoritmais gautos tarpų sekos veikia greičiau už Sedgewick seką, kuri literatūroje laikoma viena efektyviausių.

\pagebreak

Darbo \textbf{tikslas}:
pritaikyti genetinius algoritmus Šelo algoritmo tarpų sekoms generuoti.

Darbo uždaviniai:
\begin{itemize}
  \item Atlikti Šelo rikiavimo algoritmo literatūros analizę.
  \item Nustatyti kriterijus tarpų sekų efektyvumui įvertinti.
  \item Naudojant genetinius algoritmus sugeneruoti tarpų sekas.
  \item Paruošti aplinką eksperimentų vykdymui.
  \item Atliekant eksperimentus įvertinti sugeneruotų ir pateiktų literatūroje tarpų sekų efektyvumą.
\end{itemize}

Šis darbas sudarytas iš 5 skyrių.
Pirmame skyriuje atliekama Šelo rikiavimo algoritmo literatūros analizė.
Antrame skyriuje nustatomi kriterijai tarpų sekų efektyvumui įvertinti.
Trečiame skyriuje naudojant genetinius algoritmus generuojamos tarpų sekos.
Ketvirtame skyriuje paruošiama eksperimentų vykdymo aplinka.
Penktame skyriuje atliekant eksperimentus įvertinamas sugeneruotų ir pateiktų literatūroje tarpų sekų efektyvumas.

\section{Šelo rikiavimo algoritmas}

\subsection{Šelo rikiavimo algoritmo sparta}

\subsubsection{Veikimo greitis priklausomai nuo duomenų dydžio}

Renkantis kokį algoritmą naudoti, labai svarbu įvertinti tikėtiną duomenų dydį.
Šelo rikiavimo algoritmas veikia greičiausiai, kai duomenų dydis yra ganėtinai mažas \cite{ciura2001best}.
Kaip teigiama \cite{simpson1999faster}, ši savybė galioja, kai $N \leq 106$.
Tokiu atveju, Šelo algoritmas lenkia net ir vienu greičiausių laikomą greitojo rikiavimo algoritmą.
Todėl Šelo rikiavimo algoritmas dažnai naudojamas hibridiniuose rikiavimo algoritmuose, kai pasiekus tam tikrą rekursijos lygį
rikiuojamų duomenų dalis tampa pakankamai maža ir tolimesnė rekursija asimptotiškai optimaliu algoritmu nebeturi prasmės,
kadangi jos tęsimas reikalautų per daug mašinos resursų.
Tokių šio algoritmo naudojimo pavyzdžių galima rasti Go programavimo kalbos standartinėje bibliotekoje \cite{golangsort} bei
bzip2 failų glaudinimo programoje \cite{bzip2sort}.
Tiesa, net ir rikiuojant didesnius duomenų dydžius, Šelo algoritmas nėra labai lėtas \cite{ciura2001best}.
Todėl jis yra vertingas įrankis įgyvendinant operacinės sistemos branduolį ar programuojant įterptinėms sistemoms, kadangi dėl ribotų atminties išteklių
asimptotiškai optimalūs algoritmai, kurie dažniausia yra rekursyvūs ir naudoja daugiau atminties, tokiais atvejais netinka.
Taigi, nors Šelo rikiavimo algoritmas nėra labai greitas, kai uždavinys didelis,
yra scenarijų, kuriais jį rinktis tikrai verta.

\subsubsection{Veikimo greitis priklausomai nuo duomenų specifikos}

Viena palankiausių Šelo algoritmo savybių yra jo adaptyvumas.
Adaptyvumas rikiavimo algoritmų kontekste reiškia, jog algoritmas atlieka mažiau operacijų, jei duomenys dalinai išrikiuoti.
Adaptyvumą Šelo algoritmas paveldi iš rikiavimo įterpimu, nes yra jo optimizacija.
Moksliniuose tyrimuose ši savybė retai turi įtakos, kadangi dažniausia siekiama ištirti algoritmo veikimą, kai duomenys
nėra tvarkingai išdėstyti ir tipiškai renkamasi atsitiktinai generuoti pradinius duomenis šiam tikslui pasiekti.
Savaime aišku, jog praktikoje retai pavyks sutikti visiškai atsitiktinai išsidėsčiusius duomenis, neturinčius nei vieno išrikiuoto posekio ilgesnio nei 1.
Kaip parodo \cite{10.1145/359024.359026}, Šelo algoritmas veikia net keletą kartų greičiau, kai duomenys yra pilnai
išrikiuoti ir veikimo sparta nusileidžia tik rikiavimui įterpimu su visais duomenų dydžiais.
Kai duomenų dydis nedidelis (iki 200 elementų) ir 20\% elementų nėra teisingose pozicijose, Šelo algoritmas veikimo sparta nusileidžia tik greitojo rikiavimo algoritmui.
Palankūs rezultatai pateikiami ir \cite{7280062} - su dalinai išrikiuotais duomenimis Šelo algoritmas veikia apytiksliai 1.5 karto greičiau, o su išrikiuotais
duomenimis pasiekiamas apie 3.8 karto mažesnis veikimo greitis.
Taigi rikiuojant bent dalinai išrikiuotus duomenis Šelo algoritmas veikia žymiai greičiau.

\subsection{Šelo rikiavimo algoritmo versijos}

\subsubsection{Vadovėlinis Šelo rikiavimo algoritmas}

Kaip ir daugelis algoritmų, Šelo rikiavimo algoritmas turi keletą galimų implementacijų.
Žinomiausia iš jų, be abejo, yra vadovėlinė šio algoritmo versija (toliau - VŠA),
kurią D. L. Shell paskelbė dar 1959 metais \cite{shell1959high}.
Jos pseudokodas pateikiamas \ref{alg:tss} algoritme.

Įdėmiau įsižiūrėjus, nesunku pastebėti Šelo algoritmo panašumą į paprastą rikiavimą įterpimu - pašalinus išorinį ciklą, iteruojantį tarpų sekos narius bei pakeitus
kintamąjį $gap$ į $1$, gaunamas būtent šio algoritmo kodas.
Paties rikiavimo įterpimu idėja yra gana paprasta: pradžioje rikiuojama seka yra suskaidoma į du posekius,
kur kairysis (susidedantis iš kairiausio sekos elemento) yra išrikiuotas, o dešinysis (susidedantis iš visų likusių sekos elementų) - ne.
Tada kiekvieną iteraciją išrikiuotas posekis yra plečiamas, imant kairiausią neišrikiuoto posekio elementą ir įterpiant jį į išrikiuotą posekį.
Naujų elementų įterpimas į išrikiuotą posekį vyksta iteratyviai sukeičiant įterpiamą elementą su elementu, esančiu jam iš kairės, jei šis yra didesnis už įterpiamą elementą.
Algoritmas baigia darbą, kai neišrikiuoto posekio ilgis yra 0.

Verta pastebėti, jog Šelo algoritmas tėra rikiavimo įterpimu generalizacija, kur įterpimas gali vykti atstumu, didesniu nei 1.
Būtent didesnis įterpimo atstumas ir suteikia Šelo algoritmui pranašumą, kadangi labiausiai nuo galutinės pozicijos nutolę elementai gali greičiau patekti į reikiamą poziciją.
Šelo algoritmo idėjos turi tvirtą matematinį pagrindą: rikiavimas įterpimu turi $O(n^2)$ laiko sudėtingumą blogiausiu atveju (pavyzdžiui, kai rikiuojama seka yra išrikiuota atgaline tvarka),
tačiau kai didžiausias atstumas tarp dviejų neišrikiuotų elementų yra $k$, rikiavimo įterpimu laiko sudėtingumas yra $O(kn)$.
Taigi seką $h$-išrikiavus, paskutinė iteracija turės $O(hn)$ laiko sudėtingumą.
Iteracijos su dideliais tarpais taip pat yra gana greitos, kadangi dirbama su daug mažesniais elementų kiekias,
o šiuo atveju rikiavimas įterpimu yra vienas greičiausių.


\begin{algorithm}[H]
  \caption{Vadovėlinis Šelo rikiavimo algoritmas}\label{alg:tss}
  \begin{algorithmic}[1]
  \ForEach {$gap$ \textbf{in} $H$}
    \For {$i\gets gap+1$ \textbf{to} $N$}
      \State $j\gets i$
      \State $temp\gets S[i]$\label{alg:tss:assign1}
      \While {$j > gap$ \textbf{and} $S[j - gap] > S[j]$}\label{alg:tss:while:start}
        \State $S[j]\gets S[j - gap]$
        \State $j\gets j-gap$
      \EndWhile\label{alg:tss:while:end}
      \State $S[j]\gets temp$\label{alg:tss:assign2}
    \EndFor
  \EndFor
  \end{algorithmic}
\end{algorithm}

\subsubsection{Patobulintas Šelo rikiavimo algoritmas}

Verta pastebėti, jog vadovėlinė Šelo algoritmo implementacija nėra pilnai efektyvi \cite{Radavičius_Baranauskas_2013}.
Vykdant vidinį vadovėlinio Šelo algoritmo ciklą (\ref{alg:tss} algoritmo \ref{alg:tss:while:start}-\ref{alg:tss:while:end} eilutės),
\ref{alg:tss:while:start} eilutėje yra tikrinama, ar $S[j]$ jau yra tinkamoje pozicijoje.
Jei $S[j]$ jau yra tinkamoje pozicijoje, vidinis ciklas nėra vykdomas ir jokių elementų pozicijos nėra keičiamos.
Tačiau \ref{alg:tss:assign1} ir \ref{alg:tss:assign2} eilutėse vis tiek yra vykdomi du priskyrimai,
kurie šiuo atveju nueina veltui (o taip nutinka pakankamai dažnai).
Siekiant tai ištaisyti, \cite{Radavičius_Baranauskas_2013} pateikė patobulintą Šelo algoritmo versiją (toliau - PŠA),
kurią galima rasti \ref{alg:iss} algoritme.

PŠA prieš vykdydamas bet kokius kitus žingsnius patikrina, ar elementas $S[j]$ jau yra tinkamoje pozicijoje
(žr. \ref{alg:iss} algoritmo \ref{alg:iss:check} eil.), kas leidžia sumažinti atliekamų priskyrimų skaičių,
kai su $S[j]$ pagrindinės rikiavimo logikos (\ref{alg:iss} algoritmo \ref{alg:iss:inner:start}-\ref{alg:iss:inner:end} eil.) nėra reikalo vykdyti.
Taip pat, kadangi iš pat pradžių yra užtikrinama, jog galima atlikti nors vieną sukeitimą,
vadovėlinio Šelo algoritmo $while$ ciklą (\ref{alg:tss} algoritmo \ref{alg:tss:while:start}-\ref{alg:tss:while:end} eil.)
galima pakeisti $repeat\,...\,until$ tipo ciklu, kas ir yra atliekama \ref{alg:iss} algoritmo \ref{alg:iss:loop:start}-\ref{alg:iss:loop:end} eilutėse.

Reikia pastebėti, jog patobulintas Šelo algoritmas nuo vadovėlinės versijos atliekamų operacijų prasme skiriasi tik
atliekamais priskyrimais.
Tačiau šios optimizacijos svarba pasirodo pakankamai didelė -
autorių teigimu \cite{Radavičius_Baranauskas_2013}, PŠA vidutiniškai atlieka 40-80\% mažiau priskyrimų ir veikia 20\% greičiau, nei VŠA.
Tiesa, PŠA nėra plačiai naudojamas, o jo veikimas vidutiniu atveju originaliame darbe ištirtas tik rėžyje $500 \leq N \leq 2000$.

\begin{algorithm}[H]
  \caption{Patobulintas Šelo rikiavimo algoritmas}\label{alg:iss}
  \begin{algorithmic}[1]
  \ForEach {$gap$ \textbf{in} $H$}
    \For {$i\gets gap+1$ \textbf{to} $N$}
      \If {$S[i-gap] > S[i]$}\label{alg:iss:check}
        \State $j\gets i$\label{alg:iss:inner:start}
        \State $temp\gets S[i]$
        \Repeat\label{alg:iss:loop:start}
          \State $S[j]\gets S[j - gap]$
          \State $j\gets j-gap$
        \Until {$j \le gap$ or $S[j - gap] \le S[j]$}\label{alg:iss:loop:end}
        \State $S[j]\gets temp$\label{alg:iss:inner:end}
      \EndIf
    \EndFor
  \EndFor
  \end{algorithmic}
\end{algorithm}

\section{Tarpų sekų efektyvumo kriterijų nustatymas}

Šelo algoritmo tarpų sekų efektyvumo įvertinimas nėra trivialus.
Rikiavimo algoritmai dažniausiai yra vertinami pagal atliekamų priskyrimų skaičių, kadangi
daugelyje algoritmų priskyrimų skaičius uždaviniui augant greitai artėja prie palyginimų skaičiaus ir
tokiu metodu gautas įvertis būna pakankamai tikslus.
Tačiau Šelo algoritmo atveju, atliekamų palyginimų ir priskyrimų skaičiaus santykis augant $N$ nebūtinai artėja prie 1 \cite{Radavičius_Baranauskas_2013}.
Taigi, vien priskyrimų skaičius nėra pakankamai tikslus kriterijus tarpų sekų efektyvumui įvertinti,
kadangi juo remiantis gautas įvertis pilnai neatspindi praktinio sekos efektyvumo.
Kaip parodo \cite{ciura2001best}, šiame algoritme dominuojanti operacija yra palyginimas ir efektyvios sekos
turėtų jų atlikti kuo įmanoma mažiau.
Apibendrinant, atliekamų palyginimų skaičius yra tinkamesnis kriterijus Šelo algoritmo tarpų sekų efektyvumui įvertinti.

Matuojant rikiavimo algoritmo efektyvumą tik naudojant sveikaskaitinius pradinius duomenis, gauti rezultatai gali būti netikslūs,
kadangi palyginimo ir priskyrimo operacijų sparta priklauso nuo rikiuojamų duomenų tipo.
Rikiuojant simbolių eilutes, priskyrimas atliekamas naudojant rodykles, kas yra $O(1)$ operacija,
tačiau palyginimas yra $O(n)$ blogiausiu atveju.
Ir atvirkščiai, rikiuojant įrašus, priskyrimas reikalauja perkopijuoti visą įrašą, tad šios operacijos sudėtingumas yra $O(n)$,
o palyginimas gali būti atliekamas naudojant tam tikrą raktą, taigi tik $O(1)$.
Todėl apsiriboti vien palyginimų ar priskyrimų skaičiumi nepakanka, kadangi tiksliausia praktinio algoritmo
veikimo laiko aproksimacija (tai, kam ir skaičiuojamos operacijos), bus gauta tik įvertinant abu šiuos rodiklius.

Algoritmo veikimo laikas, nors ir priklausomas nuo platformos, kurioje vykdomas tyrimas, detalių,
taip pat gali duoti tinkamų įžvalgų įvertinant praktinį efektyvumą.
Kadangi algoritmo atliekamos operacijos skaičiuojamos tam, jog gauti
veikimo laiko aproksimaciją, tai realus veikimo laikas
yra konkretus įvertis, leidžiantis praktiškai įvertinti duotos sekos efektyvumą.
Taigi, įvertinant tarpų sekų efektyvumą bus remiamasi visomis atliekamomis operacijomis bei realiais veikimo laikais.

Autoriaus nuomone, atliktų palyginimų skaičius yra svarbiausias kriterijus tarpų sekų efektyvumui įvertinti ir
atliekant vertinimą didžiausias svoris turėtų būti teikiamas būtent jam.
Vertinant kitus du kriterijus, didesnis svoris turėtų atitekti atliekamų palyginimų skaičiui,
kadangi veikimo laiko įvertis nėra universalus.
Verta pastebėti, jog atliktų priskyrimų skaičių reikia vertinti, atsižvelgiant į kontekstą, kadangi
seka, kuri atlieka daug priskyrimų, nebūtinai yra neefektyvi - daug svarbesnis yra atliekamų palyginimų ir priskyrimų santykis.
Tai galima paaiškinti paprastu pavyzdžiu: jei su tam tikra tarpų seka Šelo algoritmas atlieka santykinai mažai palyginimų ir daug priskyrimų, galima laikyti,
jog su ja algoritmas dirba pakankamai efektyviai, kadangi atlikti palyginimai nenueina veltui ir rikiuojamos sekos $S$ elementai greitai artėja link galutinės pozicijos.
Reikia atsižvelgti ir į tai, jog vadovėlinė Šelo algoritmo implementacija dažnai atlieka nereikalingus priskyrimus,
tad atliekant sekų vertinimą, yra tikslinga įvertinti sekas naudojant ir VŠA, ir PŠA \cite{Radavičius_Baranauskas_2013}.
Savaime suprantama, jog į veikimo laiką verta žvelgti kritiškai, kadangi jis priklauso nuo algoritmo implementacijos,
eksperimentams naudojamos mašinos techninių parametrų, operacinės sistemos, pasirinktos programavimo kalbos ar net kompiliatoriaus versijos.
Todėl vertinant veikimo laiką, svarbiausia atsižvelgti į santykinius gautų rezultatų skirtumus naudojant skirtingas tarpų sekas.

\section{Tarpų sekų generavimas}

\subsection{Genetiniai algoritmai}

Prieš pradedant generuoti sekas, reikalinga plačiau apžvelgti genetinio algoritmo sąvoką.
Paprasčiausias genetinis algoritmas susideda iš chromosomų populiacijos bei atrankos, mutacijos ir rekombinacijos operatorių.
Toliau bus nagrinėjamos šių terminų reikšmės ir GA veikimo principai.

Chromosoma GA kontekste vadiname potencialų uždavinio sprendinį.
Projektuojant genetinį algoritmą tam tikro uždavinio sprendimui, svarbu tinkamai pasirinkti,
kaip kompiuteriu modeliuoti galimus sprendinius (chromosomas).
Chromosomos kompiuterio atmintyje standartiškai išreiškiamos bitų eilutėmis,
kadangi tai palengvina tiek mutaciją (pakanka apversti kurio nors atsitiktinio bito reikšmę),
tiek rekombinaciją (pakanka perkopijuoti pasirinktus tėvinių chromosomų bitus į vaikinę chromosomą).
Tiesa, tai nėra vienintelis įmanomas būdas, ir kai kurių uždavinių sprendiniai modeliuojami pvz. grafu ar simbolių eilute.

Sprendinio kokybę įvardijame kaip jo tinkamumą, kuris apibrėžiamas tinkamumo funkcijos reikšme, pateikus sprendinį kaip parametrą.
Nesunku pastebėti, jog tinkamumo funkcija tėra tikslo funkcijos specializacija, kuri naudojama chromosomų vertinimui.
Tinkamumo funkcija yra viena svarbiausių genetinio algoritmo dalių,
kadangi kai ji netinkamai parinkta, algoritmas nekonverguos į tinkamą sprendinį arba užtruks labai ilgai.

Chromosomų rinkinys, literatūroje dažnai vadinamas populiacija, atspindi uždavinio sprendinių aibę, kuri kinta kiekvieną genetinio algoritmo iteraciją.
Jei GA suprojektuotas tinkamai, dažnu atveju vidutinis populiacijos tinkamumas gerės kiekvieną iteraciją \cite{simpson1999faster}.
Esminė GA dalis yra populiacijos genetinės įvairovės užtikrinimas, geriausių individų atranka ir kryžminimasis.
Šiems procesams nesunku rasti atitikmenis nagrinėjant gamtoje vykstančius evoliucinius reiškinius.

Genetinis algoritmas vykdymo metu iteratyviai atnaujina esamą populiaciją, kurdamas naujas kartas taikant atrankos, rekombinacijos ir mutacijos operatorius.

Atrankos operatorius grąžina tinkamiausius populiacijos individus, kuriems yra leidžiama susilaukti palikuonių taikant rekombinacijos operatorių.
Dažniausiai atranka vykdoma atsižvelgiant į populiacijos individų tinkamumą, atrenkant ir pateikiant rekombinacijai tuos, kurių tinkamumas yra geriausias.

Rekombinacijos operatorius veikia iš dviejų tėvinių chromosomų sukurdamas naują vaikinę chromosomą, kas dažniausiai pasiekiama
tam tikru būdu perkopijuojant tėvų genų atkarpas į vaikinę chromosomą.
Rekombinacijos strategijų yra įvairių, tačiau ne kiekvienam uždaviniui visos jos tinka, kadangi
kai kuriais atvejais netinkamai parinkta rekombinacijos strategija pagamina neatitinkančią uždavinio apribojimų vaikinę chromosomą.
Pavyzdžiui, jei modeliuojama chromosoma yra sąrašas, turintis susidėti iš tam tikrų elementų, neįmanoma garantuoti, jog atsitiktinai
perkopijavus tėvinių chromosomų genus į vaikinę chromosomą šis apribojimas bus išlaikytas.

Galiausiai tam tikrai populiacijos daliai yra pritaikomas mutacijos operatorius.
Jo veikimo principas yra gana paprastas: pasirinktos chromosomos vienas ar keli genai yra modifikuojami,
nežymiai pakeičiant jų reikšmes ar sukeičiant kelių genų reikšmes vietomis.
Mutacijos operatorius praplečia vykdomos paieškos erdvę, o tai labai svarbu, kadangi kitaip algoritmas gali konverguoti
į lokaliojo minimumo taškus, taip ir nepasiekdamas globaliojo minimumo.
Atsižvelgiant į tai, yra laikoma, jog mutacijos operatorius yra kertinė genetinio algoritmo dalis,
kuri palaiko genetinę individų įvairovę ir padeda rasti tinkamiausius sprendinius.

Kad genetinis algoritmas neveiktų amžinai, yra pasirenkama viena ar kelios sustojimo sąlygos, pavyzdžiui: pasiektas maksimalus
kartų skaičius, vidutinio tinkamumo pokytis tarp paskutinių dviejų populiacijos kartų pakankamai mažas, etc.
Kiekvieną iteraciją GA patikrina, ar kažkuri iš sustojimo sąlygų yra patenkinta, ir jei taip - baigia darbą.

Apjungiant visas aukščiau aptartas genetinio algoritmo dalis, galima suformuluoti paprasto genetinio algoritmo pseudokodą.
Jis pateikiamas \ref{simple_GA} algoritme.

\begin{algorithm}[H]
  \caption{Paprastas GA}\label{simple_GA}
  \begin{algorithmic}
    \State Let $current\_population$ be a random population of chromosomes.
    \State Let $mutation\_rate$ be a real value between 0 and 1.
    \State Let $crossover\_fraction$ be a real value between 0 and 1.
    \Repeat
      \State Apply the fitness function to each chromosome in $current\_population$.
      \State Sort the chromosomes in $current\_population$ based on their fitness. % cia reikia pataisyti
      \State Let $new\_population$ be an empty set.
      \Repeat
        \State Let $(parent1, parent2)$ be a pair of parent chromosomes selected randomly from the first $[N * crossover\_fraction]$ elements of $current\_population$.
        \State Let $child\_chromosome$ be the result of applying the crossover operator to $parent1$ and $parent2$.
        \If {$rand() < mutation\_rate$}
          \State Apply the mutation operator to $child\_chromosome$
        \EndIf
        \State Add $child\_chromosome$ to $new\_population$
      \Until N offspring have been created.
      \State Assign $new\_population$ to $current\_population$.
    \Until Termination criteria are satisfied.
  \end{algorithmic}
\end{algorithm}

\subsection{Trumpų tarpų sekų generavimas}
Pirmame etape buvo generuojamos tarpų sekos, kurios efektyvios kai $N=1000$.
Trumpų sekų generavimui buvo paruoštas vienkriterinis genetinis algoritmas.
GA implementacijai buvo pasirinkta OpenGA biblioteka \cite{mohammadi2017openga}
dėl suteikiamos laisvės pasirinkti, kaip įgyvendinti genetinius operatorius bei modernių kalbos konstruktų ir lygiagretaus vykdymo palaikymo.
Remiantis \cite{simpson1999faster}, trumpos sekos chromosoma buvo modeliuojama kaip
septynių sveikų skaičių masyvas.
Chromosomos buvo vertinamos jas naudojant 20 atsitiktinai
sugeneruotų sveikų skaičių masyvų, turinčių po 1000 elementų, rikiavimui vadovėline Šelo rikiavimo algoritmo versija ir skaičiuojant atliktas palyginimo operacijas.
Chromosomos tinkamumo funkcija buvo apibrėžta kaip atliktų palyginimų skaičiaus aritmetinis vidurkis.
Rekombinacijos operatorius buvo įgyvendintas tolygia strategija, kur abiejų tėvų genai turi vienodą tikimybę
būti perduoti vaikinei chromosomai.
GA sustojimo kriterijumi buvo pasirinkta laikyti tinkamiausio individo nepakitimą 25 iteracijas.
Mutacijos operatorius buvo įgyvendintas su $\frac{1}{5}$ tikimybe keičiant tam tikrą chromosomą,
pridedant prie atsitiktinai pasirinkto geno reikšmės skaičių $\left[(rand01()-rand01())*\frac{25}{\sqrt{karta}}\right]$ su apribojimu, jog pakeistas genas turi priklausyti intervalui $[1, 1000]$.
Siekiant išvengti netinkamų sprendinių, kiekviena seka po rekombinacijos ar mutacijos operatorių taikymo buvo išrikiuojama ir
užtikrinama, jog paskutinis sekos narys yra 1.

GA buvo vykdomas su atsitiktinai sugeneruota 10000 individų populiacija, kiekvieną iteraciją pritaikant rekombinacijos operatorių
$\frac{1}{2}$ populiacijos.
Tokiu būdu buvo sugeneruota ir atrinkta 10 sekų.
Po to iš visų sugeneruotų sekų buvo atrinkta tinkamiausia, sugeneruotas sekas naudojant 10000 atsitiktinai sugeneruotų masyvų, turinčių po 1000 elementų, rikiavimui
ir matuojant atliktų palyginimo operacijų aritmetinį vidurkį.
Atlikus matavimus, buvo pasirinkta seka $855, 264, 86, 35, 12, 5, 1$ (toliau - S1).

\subsection{Vidutinio ilgio tarpų sekų generavimas}
Antrame etape buvo generuojamos tarpų sekos, kurios efektyvios kai $N=100000$.
Vidutinio ilgio sekų generavimui buvo pasitelktas modifikuotas genetinis algoritmas, naudotas generuojant trumpas tarpų sekas.
Tarpų sekos chromosoma buvo modeliuojama kaip 12 sveikų skaičių masyvas.
Buvo atsisakyta chromosomų vertinimo naudojant 20 skirtingų masyvų, kadangi tai darė neigiamą įtaką genetinio algoritmo veikimo laikui.
Vietoje to, kiekvienos sekos vertinimui buvo naudojami 5 atsitiktinai sugeneruoti 100000 elementų masyvai.
GA buvo nurodyta sustoti, kai kartų skaičius pasieks 100.
Mutacijos operatorius buvo pakoreguotas ir su $\frac{1}{5}$ tikimybe keitė tam tikrą chromosomą,
pridedant prie atsitiktinai pasirinkto geno reikšmės skaičių $\left[(rand01()-rand01())*\frac{75}{\sqrt{karta}}\right]$.

GA buvo vykdomas su atsitiktinai sugeneruota 1000 individų populiacija,
paskutinius septynis kiekvienos chromosomos genus inicializuojant elementais $855, 264, 86, 35, 12, 5, 1$, t.y. sekos, gautos pirmame etape, nariais.
Siekiant išlaikyti tinkamiausius sprendinius, buvo pasitelktas elitizmas - didžiausią tinkamumą turinčios 75 chromosomos nekeistos
patekdavo į kitą algoritmo iteraciją.
Rekombinacijos operatorius buvo taikomas $\frac{1}{2}$ populiacijos kiekvieną algoritmo iteraciją.
Tokiu būdu buvo sugeneruota ir atrinkta 10 sekų.
Po to iš visų sugeneruotų sekų buvo atrinkta tinkamiausia, naudojant tokį pat metodą kaip ir praeitame etape, tik pakeitus rikiuojamų masyvų dydį į 100000.
Atlikus matavimus, buvo pasirinkta seka $45794, 17396, 7414, 3136, 1206, 561, 264, 86, 35, 12, 5, 1$ (toliau - S2).


\section{Eksperimentų vykdymo aplinkos paruošimas}

Siekant išmatuoti VŠA bei PŠA atliekamų operacijų skaičių,
buvo parengtos modifikuotos šių algoritmų versijos, kurios kaip rezultatą grąžina atliktus palyginimus bei priskyrimus.

Verta pastebėti, jog matuoti veikimo laiką naudojant operacijas skaičiuojančius algoritmus nėra tinkama,
kadangi pats operacijų skaičiavimas reikalauja papildomų žingsnių, o tai gali iškreipti gautus rezultatus.
Atsižvelgiant į tai, veikimo laiko matavimui naudoti nemodifikuoti VŠA ir PŠA algoritmai. 

Vykdant eksperimentus buvo pasirinkta naudoti sveikaskaitinius pradinius duomenis, kadangi jų generavimas yra pakankamai paprastas.
Tai buvo įgyvendinta naudojant MT19937 pseudoatsitiktinių skaičių generatorių, inicializuotą sisteminio laiko reikšme.
Generuojami duomenys buvo tolygiai paskirstyti nuo INT\_MIN iki INT\_MAX, kas leido žymiai sumažinti duomenų duplikacijos tikimybę.

Eksperimentų vykdymui buvo naudojamas kompiuteris su 2.70 GHz Intel(R) Core(TM) i7-10850H procesoriumi,
32 GB operatyviosios atminties ir Windows 10 operacine sistema.
Tyrimas buvo įgyvendintas C++ kalba su GNU g++ 8.1.0 kompiliatoriumi naudojant -O3 optimizacijos lygį.

\section{Tarpų sekų efektyvumo įvertinimas}

Iš anksto verta pastebėti, jog ne visos šiame skyriuje tiriamos tarpų sekos iš tiesų yra būtent tokio ilgio, koks pateikiamas šiame darbe.
Tačiau būtina atsižvelgti į faktą, jog tai galėtų sukelti nelygias sąlygas atliekamuose matavimuose,
kadangi seka, turinti elementų didesnių už maksimalų tiriamą $N$, atliktų nereikalingas operacijas, o per trumpa seka veiktų neefektyviai.
Siekiant standartizuoti tarpų sekų ilgius, buvo pasirinkta kai kurias sekas sutrumpinti (ar pratęsti, jei tam yra žinoma rekursyvi formulė)
taip, jog standartizuota seka būtų ilgiausia įmanoma seka, kurios visi elementai mažesni už maksimalų tiriamą $N$.
Atliekamų matavimų skaičius buvo pasirinktas atsižvelgiant į tame etape tiriamo $N$ dydį: jei $N$ labai mažas,
egzistuoja didelė tikimybė jog gautas vidutinis įvertis bus netikslus, matuojant, pavyzdžiui, tik 1000 kartų.
Todėl tiriant trumpesnes sekas buvo stengtasi atlikti daugiau matavimų.

\subsection{Trumpų tarpų sekų efektyvumo įvertinimas}
Trumpų tarpų sekų efektyvumo tyrimui buvo pasirinktos šios tarpų sekos:
\begin{itemize}
  \item Tokuda: $525, 233, 103, 46, 20, 9, 4, 1$ \cite{10.5555/645569.659879}
  \item Ciura: $701, 301, 132, 57, 23, 10, 4, 1$ \cite{ciura2001best}
  \item Simpson-Yachavaram: $893, 219, 83, 36, 13, 4, 1$ \cite{simpson1999faster}
  \item Sedgewick: $929, 505, 209, 109, 41, 19, 5, 1$ \cite{SEDGEWICK1986159}
  \item Incerpi-Sedgewick: $861, 336, 112, 48, 21, 7, 3, 1$ \cite{incerpi1985improved}
  \item S1: $855, 264, 86, 35, 12, 5, 1$
\end{itemize}

Atsižvelgiant į santykinai nedidelį duomenų dydį, matavimai buvo atlikti 50000 kartų.
Gauti duomenys pateikiami suapvalinus iki šimtosios dalies.

\subsubsection{Efektyvumo tyrimas naudojant vadovėlinį Šelo algoritmą}


\begin{table}[H]
  \caption{Vidutinis VŠA atliktų palyginimų skaičius naudojant trumpas tarpų sekas}
  \label{tss_small_comparisons}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda  & Ciura            & S/Y              & Sedgewick & I/S     & S1               \\ \hline
  50   & 289.90  & \textbf{287.76}  & \textbf{287.70}  & 293.41    & 296.37  & \textbf{289.21}  \\ \hline
  100  & 735.82  & \textbf{733.35}  & \textbf{731.49}  & 752.13    & 759.57  & \textbf{731.87}  \\ \hline
  200  & 1812.59 & \textbf{1797.92} & \textbf{1798.5}  & 1840.15   & 1870.94 & \textbf{1793.19} \\ \hline
  400  & 4315.6  & \textbf{4276.38} & \textbf{4284.94} & 4405.07   & 4464.59 & \textbf{4273.84} \\ \hline
  800  & 10061.3 & \textbf{9946.54} & \textbf{9987.18} & 10260.5   & 10528.2 & \textbf{9999.9}  \\ \hline
  1000 & 13128.9 & \textbf{13044.4} & \textbf{13075.4} & 13395.4   & 13807.4 & \textbf{13054.4} \\ \hline
  \end{tabular}
  \end{table}

\begin{table}[H]
  \caption{Vidutinis VŠA atliktų priskyrimų skaičius naudojant trumpas tarpų sekas}
  \label{tss_small_assignments}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda  & Ciura   & S/Y              & Sedgewick        & I/S     & S1               \\ \hline
  50   & 482.37  & 473.17  & \textbf{453.48}  & \textbf{447.69}  & 487.44  & \textbf{456.58}  \\ \hline
  100  & 1204.5  & 1186.33 & \textbf{1137.21} & \textbf{1130.61} & 1227.55 & \textbf{1135.35} \\ \hline
  200  & 2933.02 & 2862.17 & \textbf{2752.73} & \textbf{2761.21} & 2977.03 & \textbf{2745.81} \\ \hline
  400  & 6898.23 & 6733.29 & \textbf{6522.93} & \textbf{6629.27} & 6903.13 & \textbf{6444.15} \\ \hline
  800  & 15899.2 & 15487.9 & \textbf{14758.6} & \textbf{15354.8} & 15950   & \textbf{14745.8} \\ \hline
  1000 & 20707.8 & 20273.4 & \textbf{19200.7} & \textbf{20089.7} & 20841.4 & \textbf{19193.6} \\ \hline
  \end{tabular}
  \end{table}

\begin{table}[H]
  \caption{Vidutinis VŠA veikimo laikas (μs) naudojant trumpas tarpų sekas}
  \label{tss_small_runtimes}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda        & Ciura          & S/Y            & Sedgewick      & I/S            & S1             \\ \hline
  50   & \textbf{1.00} & 1.02           & 1.10           & \textbf{1.01}  & 1.14           & \textbf{0.90}  \\ \hline
  100  & 3.04          & \textbf{2.87}  & \textbf{2.75}  & 2.95           & \textbf{2.74}  & 3.09           \\ \hline
  200  & 6.35          & \textbf{6.25}  & \textbf{6.32}  & \textbf{6.00}  & 7.20           & 6.37           \\ \hline
  400  & 16.39         & 15.06          & \textbf{14.29} & \textbf{14.20} & \textbf{14.77} & 14.92          \\ \hline
  800  & 39.93         & \textbf{37.60} & \textbf{35.41} & 38.60          & 43.22          & \textbf{33.30} \\ \hline
  1000 & 45.74         & 44.30          & \textbf{42.07} & \textbf{42.58} & 44.44          & \textbf{44.10} \\ \hline
  \end{tabular}
  \end{table}

Kaip galima pastebėti iš \ref{tss_small_comparisons} lentelės, mažiausiai palyginimų bendru atveju atliko Ciura seka,
nedaug atsiliko S1 ir Simpson-Yachavaram sekos. Mažiausiai priskyrimų, remiantis \ref{tss_small_assignments} lentele, atliko S1 seka, nežymiai daugiau - Simpson-Yachavaram ir Sedgewick sekos.
Vertinant vidutinį veikimo laiką pateiktą \ref{tss_small_runtimes} lentelėje, sunku išskirti geriausią,
tačiau palankiausi rezultatai gauti su Sedgewick ir Simpson-Yachavaram sekomis bei S1 seka.
Todėl, įvertinant visus kriterijus, šiame etape geriausiai pasirodė Ciura, S1 ir Simpson-Yachavaram sekos.

\subsubsection{Efektyvumo tyrimas naudojant patobulintą Šelo algoritmą}


\begin{table}[H]
  \caption{Vidutinis PŠA atliktų palyginimų skaičius naudojant trumpas tarpų sekas}
  \label{iss_small_comparisons}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda   & Ciura             & S/Y               & Sedgewick & I/S      & S1                \\ \hline
  50   & 289.85   & \textbf{287.85}   & \textbf{287.83}   & 293.70    & 296.33   & \textbf{289.09}   \\ \hline
  100  & 736.17   & \textbf{733.32}   & \textbf{731.70}   & 751.94    & 759.47   & \textbf{732.01}   \\ \hline
  200  & 1812.48  & \textbf{1798.04}  & \textbf{1798.66}  & 1840.66   & 1871.29  & \textbf{1793.03}  \\ \hline
  400  & 4315.89  & \textbf{4276.20}  & \textbf{4284.83}  & 4405.79   & 4464.40  & \textbf{4273.78}  \\ \hline
  800  & 10061.00 & \textbf{9945.74}  & \textbf{9986.13}  & 10259.80  & 10525.90 & \textbf{9999.26}  \\ \hline
  1000 & 13130.80 & \textbf{13044.10} & \textbf{13077.20} & 13393.00  & 13807.50 & \textbf{13053.10} \\ \hline
  \end{tabular}
  \end{table}

\begin{table}[H]
  \caption{Vidutinis PŠA atliktų priskyrimų skaičius naudojant trumpas tarpų sekas}
  \label{iss_small_assignments}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda            & Ciura             & S/Y             & Sedgewick         & I/S             & S1                \\ \hline
  50   & \textbf{312.13}   & \textbf{319.66}   & 322.80          & 335.37            & \textbf{322.30} & 323.76            \\ \hline
  100  & \textbf{791.06}   & \textbf{797.73}   & \textbf{811.35} & 853.82            & 822.16          & 814.18            \\ \hline
  200  & \textbf{1931.99}  & \textbf{1919.31}  & 1999.55         & 2061.03           & 1998.26         & \textbf{1996.21}  \\ \hline
  400  & \textbf{4537.96}  & \textbf{4545.12}  & 4731.20         & 4855.45           & 4767.84         & \textbf{4720.75}  \\ \hline
  800  & \textbf{10502.10} & \textbf{10587.70} & 11134.90        & \textbf{11121.30} & 11396.80        & 11222.50          \\ \hline
  1000 & \textbf{13866.10} & \textbf{13819.40} & 14510.70        & 14523.70          & 14868.70        & \textbf{14490.70} \\ \hline
  \end{tabular}
  \end{table}

\begin{table}[H]
  \caption{Vidutinis PŠA veikimo laikas (μs) naudojant trumpas tarpų sekas}
  \label{iss_small_runtimes}
  \begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
  N    & Tokuda        & Ciura         & S/Y            & Sedgewick      & I/S   & S1             \\ \hline
  50   & 1.30          & \textbf{1.26} & \textbf{1.02}  & 1.32           & 1.32  & \textbf{1.14}  \\ \hline
  100  & \textbf{3.16} & \textbf{3.16} & \textbf{3.14}  & \textbf{3.02}  & 3.36  & 3.22           \\ \hline
  200  & \textbf{7.54} & 7.95          & \textbf{7.54}  & \textbf{7.61}  & 8.11  & 8.00           \\ \hline
  400  & 18.52         & 19.00         & \textbf{17.67} & \textbf{17.29} & 18.92 & \textbf{18.18} \\ \hline
  800  & 42.96         & 42.60         & \textbf{41.81} & \textbf{40.67} & 42.23 & \textbf{41.19} \\ \hline
  1000 & 56.69         & 56.88         & \textbf{53.39} & \textbf{53.45} & 56.38 & \textbf{52.84} \\ \hline
  \end{tabular}
  \end{table}

Analizuojant atliktų palyginimų skaičių, pateikiamą \ref{iss_small_comparisons} lentelėje, rezultatai beveik nesiskiria nuo VŠA
ir geriausiai pasirodė Ciura, S1 ir Simpson-Yachavaram sekos.
Vertinant atliktų priskyrimų skaičių, rezultatai labai stipriai skiriasi nuo gautų naudojant VŠA.
Kaip matoma \ref{iss_small_assignments} lentelėje, mažiausiai priskyrimų atlieka Tokuda ir Ciura sekos.
Geriausiai šiame etape vidutinio veikimo laiko atžvilgiu, remiantis \ref{iss_small_runtimes} lentele, pasirodė Sedgewick ir Simpson-Yachavaram sekos bei S1 seka.
Įvertinant visus kriterijus, geriausi rezultatai šioje tyrimo dalyje gauti su Tokuda, Ciura ir S1 sekomis.

\subsubsection{Gautų rezultatų apibendrinimas}

Verta pastebėti, jog patobulintas Šelo algoritmas atliekamų palyginimų skaičiumi teoriškai neturėtų skirtis nuo vadovėlinės implementacijos,
tad gauti įverčiai leidžia įvertinti matavimų tikslumą atspindint Šelo algoritmo atliekamų palyginimų skaičių naudojant šias tarpų sekas vidutiniu atveju.
Gauti rezultatai rodo, jog Ciura seka atlieka mažiausiai priskyrimų vidutiniu atveju, kai $N \leq 1000$, kaip ir teigta \cite{ciura2001best}.
Atsižvelgiant į pastebimai prastesnius veikimo laikus, sunku rekomenduoti PŠA nesudėtingų tipų duomenų rikiavimui, kai $N \leq 1000$.
Tiesa, rikiuojant duomenis, kurių priskyrimas brangus, PŠA veikimo laikas tikėtinai būtų geresnis, nei VŠA, tačiau tuo įsitikinti reikėtų atskiro tyrimo.  
GA naudojimas Šelo algoritmo trumpų tarpų sekų generavimui duoda gerus rezultatus, kadangi abi GA sugeneruotos sekos (Simpson-Yachavaram ir S1)
vidutiniu atveju atlieka daugiau palyginimų tik už Ciura seką, yra vienos iš lyderių vertinant atliktų priskyrimų skaičių naudojant VŠA ir pateikia vienus geriausių veikimo laikų.
Tiesa, naudojant GA sugeneruotos sekos nėra be trūkumų: lyginant su Tokuda ir Ciura sekomis, kurios atlieka daugiau priskyrimų naudojant VŠA, šios sekos atlieka žymiai daugiau priskyrimų
naudojant PŠA, nei Tokuda ir Ciura sekos. Tai sukelia klausimų dėl jų efektyvumo, kadangi PŠA pašalina tik nereikalingai atliekamus priskyrimus.
Stebina faktas, jog naudojant VŠA gauti rezultatai yra 10-20\% geresni kai $N \geq 200$, nei gauti
naudojant PŠA, nors su PŠA atliktų operacijų skaičiai yra žymiai mažesni.
Taip pat verta pastebėti, jog su PŠA atliktų palyginimų ir priskyrimų skaičiaus santykis artėja prie 1 augant N, priešingai nei naudojant VŠA.

\subsection{Vidutinio ilgio tarpų sekų efektyvumo įvertinimas}

Vidutinio ilgio tarpų sekų efektyvumo tyrimui buvo pasirinktos šios tarpų sekos:
\begin{itemize}
  \item Tokuda: $68178,30301,13467,5985,2660,1182,525,233,103,46,20,9,4,1$ \cite{10.5555/645569.659879}
  \item Ciura: $90927,40412,17961,7983,3548,1577,701,301,132,57,23,10,4,1$ \cite{ciura2001best}
  \item Simpson-Yachavaram: $38291,22927,8992,3568,1488,893,219,83,36,13,4,1$ \cite{simpson1999faster}
  \item Incerpi-Sedgewick: $86961,33936,13776,4592,1968,861,336,112,48,21,7,3,1$ \cite{incerpi1985improved}
  \item Sedgewick: $64769,36289,16001,8929,3905,2161,929,505,209,109,41,19,5,1$ \cite{SEDGEWICK1986159}
  \item Roos et al.: $91433,72985,13229,5267,2585,877,155,149,131,23,8,1$ \cite{roos2002genetic}
  \item S2: $45794,17396,7414,3136,1206,561,264,86,35,12,5,1$
\end{itemize}

Atsižvelgiant į duomenų dydį, matavimai buvo atlikti 10000 kartų.
Gauti duomenys pateikiami suapvalinus iki sveikosios dalies.

\subsubsection{Efektyvumo tyrimas naudojant vadovėlinį Šelo algoritmą}

\begin{table}[H]
  \caption{Vidutinis VŠA atliktų palyginimų skaičius naudojant vidutinio ilgio tarpų sekas}
  \label{tss_medium_comparisons}
  \begin{tabular}{|l|l|l|l|l|l|l|l|}
  \hline
  N      & Tokuda           & Ciura            & S/Y     & I/S     & Sedgewick & R/B/H/Z & S2               \\ \hline
  5000   & \textbf{86930}   & \textbf{86490}   & 88075   & 93869   & 89056     & 102065  & \textbf{87131}   \\ \hline
  10000  & \textbf{192625}  & \textbf{191703}  & 195221  & 209514  & 197067    & 225459  & \textbf{193092}  \\ \hline
  20000  & \textbf{423598}  & \textbf{421301}  & 429228  & 465748  & 433320    & 493530  & \textbf{423824}  \\ \hline
  40000  & \textbf{922922}  & \textbf{918490}  & 936240  & 1032259 & 943633    & 1070908 & \textbf{923609}  \\ \hline
  80000  & \textbf{1999095} & \textbf{1992131} & 2033327 & 2273358 & 2045446   & 2317061 & \textbf{2002290} \\ \hline
  100000 & \textbf{2564038} & \textbf{2552126} & 2605061 & 2923557 & 2623763   & 2959526 & \textbf{2563334} \\ \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \caption{Vidutinis VŠA atliktų priskyrimų skaičius naudojant vidutinio ilgio tarpų sekas}
  \label{tss_medium_assignments}
  \begin{tabular}{|l|l|l|l|l|l|l|l|}
  \hline
  N      & Tokuda  & Ciura            & S/Y              & I/S     & Sedgewick & R/B/H/Z & S2               \\ \hline
  5000   & 134747  & \textbf{132482}  & \textbf{129043}  & 138209  & 133685    & 140459  & \textbf{129181}  \\ \hline
  10000  & 296787  & \textbf{292056}  & \textbf{284474}  & 306461  & 295196    & 311298  & \textbf{284895}  \\ \hline
  20000  & 648807  & \textbf{638480}  & \textbf{623546}  & 672463  & 650675    & 680242  & \textbf{622844}  \\ \hline
  40000  & 1407318 & \textbf{1385991} & \textbf{1358871} & 1473610 & 1414589   & 1466640 & \textbf{1352658} \\ \hline
  80000  & 3034012 & \textbf{3001389} & \textbf{2959087} & 3214096 & 3072581   & 3127946 & \textbf{2925254} \\ \hline
  100000 & 3888404 & \textbf{3836014} & \textbf{3777087} & 4124557 & 3941499   & 4007456 & \textbf{3735445} \\ \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \caption{Vidutinis VŠA veikimo laikas (μs) naudojant vidutinio ilgio tarpų sekas}
  \label{tss_medium_runtimes}
  \begin{tabular}{|l|l|l|l|l|l|l|l|}
  \hline
  N      & Tokuda & Ciura        & S/Y            & I/S   & Sedgewick     & R/B/H/Z       & S2            \\ \hline
  5000   & 312    & \textbf{310} & \textbf{294}   & 330   & 311           & \textbf{296}  & 314           \\ \hline
  10000  & 707    & 702          & \textbf{671}   & 690   & 695           & \textbf{618}  & \textbf{688}  \\ \hline
  20000  & 1611   & 1550         & 1515           & 1577  & \textbf{1484} & \textbf{1345} & \textbf{1477} \\ \hline
  40000  & 4207   & 4274         & \textbf{4067}  & 4273  & 4239          & \textbf{3728} & \textbf{4135} \\ \hline
  80000  & 9638   & 9363         & \textbf{8541}  & 9064  & 9132          & \textbf{8058} & \textbf{8745} \\ \hline
  100000 & 13810  & 12058        & \textbf{11077} & 11652 & 11976         & \textbf{9225} & \textbf{9314} \\ \hline
  \end{tabular}
\end{table}

Kaip galima pastebėti \ref{tss_medium_comparisons} lentelėje, mažiausiai palyginimų bendru atveju atliko Ciura ir Tokuda sekos, šiek tiek daugiau - seka S2.
Mažiausiai priskyrimų, remiantis \ref{tss_medium_assignments} lentele, atliko Simpson-Yachavaram ir S2 sekos.
Mažiausi veikimo laikai, pateikiami \ref{tss_medium_runtimes} lentelėje, pastebimi su Roos et al. seka, sekos S2 rezultatai taip pat palankūs.
Vertinant visus kriterijus, šiame etape geriausiai pasirodė Ciura ir Tokuda sekos bei seka S2.

\subsubsection{Efektyvumo tyrimas naudojant patobulintą Šelo algoritmą}

\begin{table}[H]
  \caption{Vidutinis PŠA atliktų palyginimų skaičius naudojant vidutinio ilgio tarpų sekas}
  \label{iss_medium_comparisons}
  \begin{tabular}{|l|l|l|l|l|l|l|l|}
  \hline
  N      & Tokuda           & Ciura            & S/Y     & I/S     & Sedgewick & R/B/H/Z & S2               \\ \hline
  5000   & \textbf{86926}   & \textbf{86499}   & 88071   & 93852   & 89060     & 102054  & \textbf{87125}   \\ \hline
  10000  & \textbf{192624}  & \textbf{191711}  & 195229  & 209574  & 197045    & 225524  & \textbf{193106}  \\ \hline
  20000  & \textbf{423593}  & \textbf{421326}  & 429232  & 465791  & 433302    & 493515  & \textbf{423825}  \\ \hline
  40000  & \textbf{922899}  & \textbf{918450}  & 936191  & 1032317 & 943633    & 1071022 & \textbf{923625}  \\ \hline
  80000  & \textbf{1998794} & \textbf{1992412} & 2033313 & 2272227 & 2045555   & 2317464 & \textbf{2002261} \\ \hline
  100000 & \textbf{2564388} & \textbf{2551823} & 2605193 & 2923248 & 2624057   & 2959855 & \textbf{2563352} \\ \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \caption{Vidutinis PŠA atliktų priskyrimų skaičius naudojant vidutinio ilgio tarpų sekas}
  \label{iss_medium_assignments}
  \begin{tabular}{|l|l|l|l|l|l|l|l|}
  \hline
  N      & Tokuda           & Ciura            & S/Y     & I/S     & Sedgewick        & R/B/H/Z & S2      \\ \hline
  5000   & \textbf{91607}   & \textbf{91536}   & 96002   & 101234  & \textbf{94353}   & 110577  & 94638   \\ \hline
  10000  & \textbf{201994}  & \textbf{202938}  & 213152  & 226716  & \textbf{208567}  & 243602  & 209125  \\ \hline
  20000  & \textbf{443461}  & \textbf{447218}  & 469964  & 503670  & \textbf{455367}  & 529908  & 459749  \\ \hline
  40000  & \textbf{967300}  & \textbf{979059}  & 1019801 & 1120974 & \textbf{991883}  & 1161681 & 1005877 \\ \hline
  80000  & \textbf{2099578} & \textbf{2125122} & 2209278 & 2479564 & \textbf{2137726} & 2521194 & 2179979 \\ \hline
  100000 & \textbf{2691737} & \textbf{2709969} & 2831031 & 3181857 & \textbf{2741611} & 3209010 & 2796455 \\ \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \caption{Vidutinis PŠA veikimo laikas (μs) naudojant vidutinio ilgio tarpų sekas}
  \label{iss_medium_runtimes}
  \begin{tabular}{|l|l|l|l|l|l|l|l|}
  \hline
  N      & Tokuda         & Ciura          & S/Y           & I/S   & Sedgewick    & R/B/H/Z        & S2            \\ \hline
  5000   & \textbf{289}   & \textbf{284}   & 307           & 325   & 335          & \textbf{300}   & 301           \\ \hline
  10000  & 758            & 773            & 732           & 753   & \textbf{666} & \textbf{601}   & \textbf{716}  \\ \hline
  20000  & \textbf{1559}  & 1635           & 1594          & 1628  & 1647         & \textbf{1468}  & \textbf{1523} \\ \hline
  40000  & 3810           & 3483           & \textbf{3426} & 3630  & 3451         & \textbf{3124}  & \textbf{3441} \\ \hline
  80000  & 8956           & 8875           & \textbf{8077} & 9163  & 9153         & \textbf{7673}  & \textbf{8767} \\ \hline
  100000 & \textbf{11080} & \textbf{11200} & 11228         & 12138 & 12006        & \textbf{10361} & 11283         \\ \hline
  \end{tabular}
\end{table}

Analizuojant atliktų palyginimų skaičių, pateikiamą \ref{iss_medium_comparisons} lentelėje, rezultatai yra panašūs į gautus tiriant VŠA
ir geriausiai pasirodė Ciura, Tokuda ir S2 sekos.
Vertinant atliktus priskyrimus, geriausi rezultatai, pateikiami \ref{iss_medium_assignments} lentelėje, buvo gauti su Tokuda, Ciura ir Sedgewick sekomis.
Nagrinėjant vidutinį veikimo laiką, pateikiamą \ref{iss_medium_runtimes} lentelėje, bendru atveju didžiausia sparta gaunama su Roos et al. ir S2 sekomis.
Vertinant visus kriterijus, geriausiai pasirodė Ciura ir Tokuda sekos.

\subsubsection{Gautų rezultatų apibendrinimas}

Gauti rezultatai rodo, jog Roos et al. seka, kaip ir teigta \cite{roos2002genetic},
veikia greičiau už Sedgewick ir Simpson-Yachavaram sekas, bent jau kai $N \leq 100000$, o pradiniai duomenys - sveiki skaičiai.
Iš tiesų, ši seka pagal gautus rezultatus yra absoliuti lyderė vertinant vidutinį veikimo laiką, tačiau būtina atsižvelgti į faktą, jog ji atlieka labai daug operacijų,
tad yra tikėtina, jog rikiuojant duomenis, kurių priskyrimas ar palyginimas yra brangus, gauti veikimo laiko rezultatai nebūtų tokie palankūs.
Ciura seka, kaip ir tiriant trumpas tarpų sekas, pagal gautus rezultatus atlieka mažiausiai priskyrimų, kas dalinai pateisina autoriaus spėjimą \cite{ciura2001best},
jog seką $701,301,132,57,23,10,4,1$ pratęsus bus gauta palyginimų atžvilgiu optimali seka ir didesniems $N$.
Simpson-Yachavaram seka, kaip ir teigė \cite{simpson1999faster} autoriai, atlieka mažiau priskyrimų ir veikia greičiau, nei Sedgewick seka.
GA naudojimas generuojant vidutinio ilgio tarpų sekas duoda gerus rezultatus: nors nė viena iš GA sugeneruotų sekų (Simpson-Yachavaram, Roos et al. ir S2) nelenkia Tokuda ir Ciura pateiktų sekų
vertinant atliktus palyginimus, S2 ir Simpson-Yachavaram sekos naudojant VŠA atlieka mažiau priskyrimų, o Roos et al. seka, kaip ir minėta anksčiau, veikia labai greitai. 
Palyginimų atžvilgiu optimalios sekos (Tokuda ir Ciura) naudojant PŠA veikia pastebimai greičiau, nei naudojant VŠA, ypač augant duomenų dydžiui.

\sectionnonum{Išvados}

Įvertinant darbe gautus rezultatus, galima teigti, jog genetiniai algoritmai yra tinkamas metodas efektyvių tarpų sekų radimui.
Šelo algoritmu rikiuojant nedidelius ($N \leq 1000$) duomenų dydžius, galima rekomenduoti Ciura ir S1 tarpų sekas.
Šelo algoritmu rikiuojant didesnius ($1000 \leq N \leq 100000$) duomenų dydžius, galima rekomenduoti Ciura ir Tokuda tarpų sekas bei patobulintą Šelo algoritmo implementaciją.


% Išvadose ir pasiūlymuose, nekartojant atskirų dalių apibendrinimų,
% suformuluojamos svarbiausios darbo išvados, rekomendacijos bei pasiūlymai.

\printbibliography[heading=bibintoc] % Literatūros šaltiniai

% \appendix  % Priedai
% Prieduose gali būti pateikiama pagalbinė, ypač darbo autoriaus savarankiškai
% parengta, medžiaga. Savarankiški priedai gali būti pateikiami kompiuterio
% diskelyje ar kompaktiniame diske. Priedai taip pat vadinami ir numeruojami.
% Tekstas su priedais siejamas nuorodomis (pvz.: \ref{img:mlp}).

\end{document}
